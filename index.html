<!DOCTYPE html>
<html lang="hi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>हिंदी टाइपिंग टेस्ट</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Noto+Sans+Devanagari:wght@400;700&family=Hind+Siliguri:wght@400;700&family=Mangal:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* --- General Body and Container Styles (Similar to English Tool) --- */
        body {
            font-family: 'Noto Sans Devanagari', 'Roboto', sans-serif; /* Prioritize Noto for Hindi, fallback to Roboto */
            background: #282c34; /* Dark background from English tool */
            color: #e0e0e0; /* Light text color */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent body scroll when overlays are active */
            line-height: 1.6;
        }

        .container {
            background: #3a3f47; /* Slightly lighter dark background for container */
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4); /* Deeper shadow */
            padding: 40px;
            width: 90%;
            max-width: 900px;
            text-align: center;
            position: relative;
            z-index: 1; /* Ensure main content is below overlays */
            box-sizing: border-box;
            border: 1px solid #4a4f57; /* Subtle border */
        }

        h1 {
            color: #61dafb; /* Light blue accent color */
            margin-bottom: 25px;
            font-size: 2.5em;
            font-weight: 700;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        /* --- Test Area Styles (Similar to English Tool) --- */
        .test-area-wrapper {
            background: #2f333a; /* Darker background for test area */
            border: 2px solid #555;
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 30px;
            text-align: left;
            position: relative;
            max-height: 220px; /* Slightly increased height */
            overflow-y: auto; /* Enable scrolling */
            font-size: 22px; /* Slightly larger font */
            line-height: 1.9;
            color: #e0e0e0; /* Light text for words */
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.3);
            transition: border-color 0.3s ease;
        }

        .test-area-wrapper:focus-within {
            border-color: #61dafb; /* Highlight on focus */
        }

        .test-area .word {
            display: inline-block;
            margin-right: 6px; /* Space between words */
            padding: 1px 0; /* Small vertical padding */
            transition: background-color 0.1s ease, transform 0.1s ease;
        }

        .test-area .word:last-child {
            margin-right: 0;
        }

        .test-area span {
            display: inline-block;
            transition: color 0.1s ease, background-color 0.1s ease;
        }

        .test-area .current-word {
            background-color: rgba(97, 218, 251, 0.2); /* Semi-transparent light blue highlight */
            border-radius: 4px;
            transform: scale(1.02); /* Slight zoom on current word */
        }

        .test-area .current-newline-marker {
            background-color: rgba(255, 165, 0, 0.3); /* Orange highlight for newline */
            border-radius: 4px;
            padding: 0 8px;
            font-weight: bold;
            color: #e0e0e0;
        }

        .test-area .correct {
            color: #4CAF50; /* Green for correct */
        }

        .test-area .incorrect {
            color: #f44336; /* Red for incorrect */
            background-color: rgba(244, 67, 54, 0.2); /* Semi-transparent red background */
            border-radius: 2px;
        }

        .test-area .untyped {
            color: #9e9e9e; /* Grey for untyped */
        }

        .test-area .extra {
            color: #FFEB3B; /* Yellow for extra characters */
            background-color: rgba(255, 235, 59, 0.2);
            border-radius: 2px;
            text-decoration: underline; /* Indicate as extra */
        }

        .test-area .newline-marker {
            display: inline-block;
            width: 100%;
            height: 1px;
            margin: 8px 0; /* More vertical spacing */
            position: relative;
        }

        .test-area .newline-marker::after {
            content: '↵'; /* Enter symbol */
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            color: #9e9e9e;
            font-size: 18px;
            padding: 0 5px;
        }

        /* --- Input Field Styles (Similar to English Tool) --- */
        .typing-input {
            width: calc(100% - 50px); /* Adjust padding */
            padding: 18px 25px;
            font-size: 26px; /* Larger font */
            border: 2px solid #555;
            border-radius: 8px;
            margin-bottom: 30px;
            background: #2f333a;
            color: #e0e0e0;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            text-align: left;
            box-shadow: inset 0 1px 5px rgba(0, 0, 0, 0.2);
        }

        .typing-input::placeholder {
            color: #888;
        }

        .typing-input:focus {
            border-color: #61dafb;
            outline: none;
            box-shadow: 0 0 15px rgba(97, 218, 251, 0.4); /* Glow effect on focus */
        }

        /* --- Stats Display (Similar to English Tool) --- */
        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 35px;
            flex-wrap: wrap;
            gap: 15px; /* Gap between stat items */
        }

        .stat-item {
            background: #2f333a;
            padding: 20px;
            border-radius: 10px;
            flex: 1;
            min-width: 150px; /* Slightly larger min-width */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            border: 1px solid #4a4f57;
            text-align: center;
        }

        .stat-item p {
            margin: 0;
            font-size: 1.1em;
            color: #b0b0b0;
            margin-bottom: 8px;
        }

        .stat-item .value {
            font-size: 2.2em; /* Larger value font */
            font-weight: bold;
            color: #61dafb; /* Primary accent color */
            display: block; /* Ensures value is on new line */
        }

        .stat-item.time .value { color: #f9d71c; } /* Yellow for Time */
        .stat-item.accuracy .value { color: #9B59B6; } /* Purple for Accuracy */
        .stat-item.errors .value { color: #E74C3C; } /* Red for Errors */
        .stat-item.cpm .value { color: #F39C12; } /* Orange for CPM */
        .stat-item.kdph .value { color: #1ABC9C; } /* Teal for KDPH */

        /* --- Progress Bars (Similar to English Tool) --- */
        .progress-section {
            margin-bottom: 25px;
        }

        .progress-bar-container {
            width: 100%;
            background-color: #555; /* Darker background for container */
            border-radius: 6px;
            height: 12px; /* Thicker bar */
            margin-top: 10px;
            overflow: hidden;
            box-shadow: inset 0 1px 5px rgba(0, 0, 0, 0.3);
        }

        .progress-bar-fill {
            height: 100%;
            width: 0%;
            border-radius: 6px;
            transition: width 0.4s ease-out; /* Smoother transition */
        }

        .progress-bar-container.wpm .progress-bar-fill { background-color: #61dafb; } /* Blue */
        .progress-bar-container.accuracy .progress-bar-fill { background-color: #9B59B6; } /* Purple */
        .progress-bar-container.errors .progress-bar-fill { background-color: #E74C3C; } /* Red */
        .progress-bar-container.cpm .progress-bar-fill { background-color: #F39C12; } /* Orange */
        .progress-bar-container.kdph .progress-bar-fill { background-color: #1ABC9C; } /* Teal */
        .progress-bar-container.time .progress-bar-fill {
            background: linear-gradient(to right, #61dafb, #f9d71c); /* Gradient for time */
        }


        /* --- Controls (Buttons - Similar to English Tool) --- */
        .controls button {
            background: #61dafb; /* Primary button color */
            color: #282c34; /* Dark text on light button */
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2em;
            margin: 0 12px;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            font-weight: 700;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .controls button:hover {
            background: #50b3e6; /* Slightly darker blue on hover */
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
        }

        .controls button:disabled {
            background: #555;
            color: #a0a0a0;
            cursor: not-allowed;
            transform: translateY(0);
            box-shadow: none;
        }

        /* --- Overlay (Settings & Result Modals - Similar to English Tool) --- */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85); /* Darker, more opaque overlay */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Higher z-index */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0s linear 0.3s;
        }

        .overlay.show {
            opacity: 1;
            visibility: visible;
            transition-delay: 0s;
        }

        .overlay-content {
            background: #3a3f47;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
            width: 90%;
            max-width: 550px; /* Slightly wider */
            text-align: left;
            transform: translateY(-30px); /* More pronounced slide-in */
            transition: transform 0.4s ease, opacity 0.4s ease;
            border: 1px solid #4a4f57;
            box-sizing: border-box;
            color: #e0e0e0;
        }

        .overlay.show .overlay-content {
            transform: translateY(0);
            opacity: 1;
        }

        .overlay-content h2 {
            color: #61dafb;
            margin-bottom: 30px;
            text-align: center;
            font-size: 2em;
            font-weight: 700;
        }

        .settings-group {
            margin-bottom: 25px;
        }

        .settings-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #b0b0b0;
            font-size: 1.1em;
        }

        .settings-group select,
        .settings-group input[type="number"],
        .settings-group textarea {
            width: calc(100% - 24px); /* Adjust padding */
            padding: 12px;
            border: 1px solid #555;
            border-radius: 6px;
            font-size: 1.05em;
            background: #2f333a;
            color: #e0e0e0;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }

        .settings-group select:focus,
        .settings-group input[type="number"]:focus,
        .settings-group textarea:focus {
            border-color: #61dafb;
            outline: none;
            box-shadow: 0 0 10px rgba(97, 218, 251, 0.3);
        }

        .settings-group textarea {
            resize: vertical;
            min-height: 120px; /* Taller textarea */
        }

        .settings-buttons {
            display: flex;
            justify-content: space-around;
            margin-top: 40px;
            gap: 20px;
        }

        .settings-buttons button {
            background: #61dafb;
            color: #282c34;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2em;
            font-weight: 700;
            flex: 1;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .settings-buttons button.secondary {
            background: #555;
            color: #e0e0e0;
        }

        .settings-buttons button:hover {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
        }
        .settings-buttons button.secondary:hover {
            background: #666;
        }


        /* --- Result Modal Specific Styles (Similar to English Tool) --- */
        #result-modal .overlay-content {
            max-width: 650px;
        }

        #result-modal h2 {
            color: #61dafb;
        }

        .result-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); /* Adjusted grid columns */
            gap: 20px; /* Increased gap */
            margin-bottom: 25px;
        }

        .result-row {
            background: #2f333a;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            border: 1px solid #4a4f57;
        }

        .result-row p {
            margin: 0;
            font-size: 1.1em;
            color: #b0b0b0;
            margin-bottom: 5px;
        }

        .result-value {
            font-size: 2.5em; /* Larger value font */
            font-weight: bold;
            display: block;
        }
        .result-value-green { color: #4CAF50; }
        .result-value-red { color: #E74C3C; }
        .result-value-purple { color: #9B59B6; }
        .result-value-orange { color: #F39C12; }
        .result-value-kdph { color: #1ABC9C; } /* Teal for KDPH */

        .error-details {
            text-align: left;
            margin-top: 25px;
            padding: 20px;
            background-color: #2f333a;
            border-radius: 10px;
            border: 1px solid #E74C3C; /* Red border for errors */
            box-shadow: 0 2px 10px rgba(231, 76, 60, 0.2);
            color: #e0e0e0;
        }

        .error-details h3 {
            color: #E74C3C;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.3em;
            text-align: center;
        }

        .error-details p {
            margin: 8px 0;
            font-size: 1.05em;
            color: #e0e0e0;
        }

        .target-status {
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px dashed #555; /* Dashed separator */
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 15px;
        }

        .target-status div {
            flex: 1;
            min-width: 160px;
            text-align: center;
            padding: 15px;
            background-color: #2f333a;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            border: 1px solid #4a4f57;
        }

        .target-status p {
            margin: 0;
            font-weight: bold;
            font-size: 1.05em;
            color: #b0b0b0;
        }

        .target-status p:last-child {
            font-size: 1.4em;
            margin-top: 5px;
        }

        .status-met {
            color: #4CAF50; /* Green */
        }

        .status-not-met {
            color: #E74C3C; /* Red */
        }

        .status-neutral {
            color: #b0b0b0; /* Grey */
        }

        .result-buttons {
            margin-top: 40px;
            display: flex;
            justify-content: space-around;
            gap: 20px;
        }

        .result-buttons button {
            background: #61dafb;
            color: #282c34;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2em;
            font-weight: 700;
            flex: 1;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .result-buttons button.secondary {
            background: #555;
            color: #e0e0e0;
        }

        .result-buttons button:hover {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
        }
        .result-buttons button.secondary:hover {
            background: #666;
        }

        /* --- Font-specific styles --- */
        .font-mangal { font-family: 'Mangal', sans-serif; }
        .font-krutidev { font-family: 'Kruti Dev 010', sans-serif; } /* Ensure this font is available to the user */
        .font-hind { font-family: 'Hind Siliguri', sans-serif; }
        .font-noto { font-family: 'Noto Sans Devanagari', sans-serif; }

        #krutidev-warning {
            background-color: #FFEB3B; /* Yellow background for warning */
            border: 1px solid #F39C12; /* Orange border */
            padding: 10px;
            margin-top: 15px;
            border-radius: 6px;
            color: #333; /* Dark text on light background */
            font-size: 1.05em;
            text-align: center;
            display: none; /* Hidden by default */
            font-weight: bold;
        }
        #krutidev-warning.show {
            display: block;
        }
        .story-link-button {
            display: block;
            margin-top: 20px; /* More space */
            background-color: #007bff; /* Blue for external link */
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1.05em;
            width: 100%;
            box-sizing: border-box;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .story-link-button:hover {
            background-color: #0056b3;
            transform: translateY(-1px);
        }


        /* Hide main content when an overlay is shown */
        .main-content.content-hidden {
            display: none;
        }

        /* --- Responsive adjustments --- */
        @media (max-width: 768px) {
            .container {
                padding: 25px;
            }
            h1 {
                font-size: 2em;
            }
            .stats {
                flex-direction: column;
                align-items: center;
            }
            .stat-item {
                width: 95%;
                max-width: 300px;
            }
            .typing-input {
                font-size: 22px;
                padding: 15px 20px;
            }
            .controls button, .settings-buttons button, .result-buttons button {
                padding: 12px 25px;
                font-size: 1em;
                margin: 0 5px;
            }
            .settings-buttons, .result-buttons {
                flex-direction: column;
                gap: 15px;
            }
            .settings-buttons button, .result-buttons button {
                width: 100%;
            }
            .result-stats {
                grid-template-columns: 1fr;
            }
            .overlay-content {
                padding: 30px;
            }
            .result-value {
                font-size: 2em;
            }
            .error-details, .target-status div {
                padding: 15px;
            }
        }
    </style>
</head>
<body>

    <div class="container main-content">
        <h1>हिंदी टाइपिंग टेस्ट</h1>
        <div class="test-area-wrapper">
            <div id="test-area" class="test-area">
                </div>
        </div>

        <input type="text" id="typing-input" class="typing-input" placeholder="टाइपिंग शुरू करें..." autofocus disabled>

        <div class="stats">
            <div class="stat-item time">
                <p>समय</p>
                <span id="countdown" class="value">05:00</span>
            </div>
            <div class="stat-item">
                <p>WPM</p>
                <span id="wpm-display" class="value">0</span>
                <div class="progress-bar-container wpm">
                    <div id="wpm-progress-bar-fill" class="progress-bar-fill"></div>
                </div>
            </div>
            <div class="stat-item accuracy">
                <p>एक्यूरेसी</p>
                <span id="accuracy-display" class="value">0%</span>
                <div class="progress-bar-container accuracy">
                    <div id="accuracy-progress-bar-fill" class="progress-bar-fill"></div>
                </div>
            </div>
            <div class="stat-item errors">
                <p>त्रुटियां</p>
                <span id="errors-display" class="value">0</span>
                <div class="progress-bar-container errors">
                    <div id="errors-progress-bar-fill" class="progress-bar-fill"></div>
                </div>
            </div>
            <div class="stat-item cpm">
                <p>CPM</p>
                <span id="cpm-display" class="value">0</span>
                <div class="progress-bar-container cpm">
                    <div id="cpm-progress-bar-fill" class="progress-bar-fill"></div>
                </div>
            </div>
            <div class="stat-item kdph">
                <p>KDPH</p>
                <span id="kdph-display" class="value">0</span>
                <div class="progress-bar-container kdph">
                    <div id="kdph-progress-bar-fill" class="progress-bar-fill"></div>
                </div>
            </div>
        </div>
        <div class="progress-bar-container time">
            <div id="time-progress-bar-fill" class="progress-bar-fill"></div>
        </div>

        <div class="controls">
            <button id="restart-button">पुनः प्रारंभ करें</button>
            <button id="settings-button">सेटिंग्स</button>
        </div>
    </div>

    <div id="settings-overlay" class="overlay">
        <div class="overlay-content">
            <h2>सेटिंग्स</h2>
            <div class="settings-group">
                <label for="test-duration">समय अवधि (मिनट):</label>
                <select id="test-duration">
                    <option value="1">1 मिनट</option>
                    <option value="2">2 मिनट</option>
                    <option value="5" selected>5 मिनट</option>
                    <option value="10">10 मिनट</option>
                    <option value="15">15 मिनट</option>
                </select>
            </div>
            <div class="settings-group">
                <label for="font-select">फ़ॉन्ट चुनें:</label>
                <select id="font-select">
                    <option value="Noto Sans Devanagari">Noto Sans Devanagari (डिफ़ॉल्ट)</option>
                    <option value="Mangal">मंगल (Mangal)</option>
                    <option value="Kruti Dev 010">कृतिदेव 010 (Kruti Dev 010)</option>
                    <option value="Hind Siliguri">हिंद सिलिगुड़ी (Hind Siliguri)</option>
                </select>
                <p id="krutidev-warning" style="display: none;">**कृतिदेव 010 एक लेगेसी फ़ॉन्ट है। इसमें कुछ अक्षर अलग तरह से टाइप हो सकते हैं।</p>
            </div>
            <div class="settings-group">
                <label for="story-type">कहानी का प्रकार:</label>
                <select id="story-type">
                    <option value="random-words">रैंडम शब्द</option>
                    <option value="ai-story">AI जेनरेटेड कहानी</option>
                    <option value="user-custom">अपनी कस्टम कहानी पेस्ट करें</option>
                </select>
                <div id="custom-story-area" style="display: none; margin-top: 15px;">
                    <label for="custom-story-textarea">अपनी कहानी यहाँ पेस्ट करें:</label>
                    <textarea id="custom-story-textarea" placeholder="अपनी कहानी पेस्ट करें..."></textarea>
                    <button id="add-story-link-button" class="story-link-button">हिंदी कहानियां खोजें</button>
                </div>
            </div>
            <div class="settings-group">
                <label for="target-wpm">लक्ष्य WPM (वैकल्पिक):</label>
                <input type="number" id="target-wpm" placeholder="उदाहरण: 40">
            </div>
            <div class="settings-group">
                <label for="target-accuracy">लक्ष्य एक्यूरेसी (वैकल्पिक %):</label>
                <input type="number" id="target-accuracy" placeholder="उदाहरण: 95">
            </div>
            <div class="settings-buttons">
                <button id="save-settings-button">टेस्ट शुरू करें</button>
                <button id="skip-settings-button" class="secondary">सेटिंग्स छोड़ें</button>
            </div>
        </div>
    </div>

    <div id="result-modal" class="overlay">
        <div class="overlay-content">
            <h2>टेस्ट परिणाम</h2>
            <div class="result-stats">
                <div class="result-row">
                    <p>WPM (शुद्ध)</p>
                    <span id="final-wpm-display" class="result-value result-value-green">0</span>
                </div>
                <div class="result-row">
                    <p>रॉ WPM</p>
                    <span id="raw-wpm-display" class="result-value result-value-purple">0</span>
                </div>
                <div class="result-row">
                    <p>एक्यूरेसी</p>
                    <span id="final-accuracy-display" class="result-value result-value-green">0%</span>
                </div>
                <div class="result-row">
                    <p>कुल त्रुटियां</p>
                    <span id="final-errors-display" class="result-value result-value-red">0</span>
                </div>
                <div class="result-row">
                    <p>CPM (कैरेक्टर प्रति मिनट)</p>
                    <span id="final-cpm-display" class="result-value result-value-orange">0</span>
                </div>
                <div class="result-row">
                    <p>KDPH (की डिप्रेशन प्रति घंटा)</p>
                    <span id="final-kdph-display" class="result-value result-value-kdph">0</span>
                </div>
            </div>
            <div class="progress-bar-container final-conclusion">
                <div id="final-conclusion-progress-bar-fill" class="progress-bar-fill"></div>
            </div>

            <div class="target-status">
                <div id="wpm-target-status">
                    <p>WPM लक्ष्य:</p>
                    <p class="status-neutral">N/A</p>
                </div>
                <div id="accuracy-target-status">
                    <p>एक्यूरेसी लक्ष्य:</p>
                    <p class="status-neutral">N/A</p>
                </div>
            </div>

            <div class="error-details">
                <h3>त्रुटि विवरण:</h3>
                <p>गलत अक्षर: <span id="err-incorrect-chars">0</span></p>
                <p>छूटे हुए अक्षर: <span id="err-missed-chars">0</span></p>
                <p>अतिरिक्त अक्षर: <span id="err-extra-chars">0</span></p>
                <p>छूटे हुए शब्द: <span id="err-skipped-words">0</span></p>
                <p>अतिरिक्त शब्द: <span id="err-extra-words">0</span></p>
                <p>गलत एंटर: <span id="err-incorrect-enter">0</span></p>
                <p>गलत स्पेस: <span id="err-incorrect-space">0</span></p>
            </div>

            <div class="result-buttons">
                <button id="modal-restart-button">पुनः टेस्ट</button>
                <button id="modal-settings-button" class="secondary">सेटिंग्स बदलें</button>
            </div>
        </div>
    </div>

    <script>
        // --- Global Variables (Declare at the top for scope) ---
        let timerInterval;
        let startTime;
        let timeLeft;
        let defaultTestDuration = 5 * 60; // Default to 5 minutes
        let wordIndex = 0;
        let charIndex = 0;
        let correctChars = 0;
        let totalTypedChars = 0;
        let testWords = [];
        let isTestRunning = false;
        let errors = {
            incorrectChars: 0,
            missedChars: 0,
            extraChars: 0,
            skippedWords: 0,
            extraWords: 0,
            incorrectEnter: 0,
            incorrectSpace: 0
        };
        let userTargetWPM = null;
        let userTargetAccuracy = null;
        let currentStoryType = 'random-words'; // Default story type
        let customStoryText = '';
        let selectedFont = 'Noto Sans Devanagari'; // Default font
        let totalExpectedCharsInTest = 0;
        let highestWPM = 0;
        let highestCPM = 0;
        let highestKDPH = 0;
        let isComposing = false; // Flag for IME composition


        // --- DOM Elements (Get references to all necessary elements once) ---
        // Main UI Elements
        const testArea = document.getElementById('test-area');
        const typingInput = document.getElementById('typing-input');
        const countdownDisplay = document.getElementById('countdown');
        const wpmDisplay = document.getElementById('wpm-display');
        const accuracyDisplay = document.getElementById('accuracy-display');
        const errorsDisplay = document.getElementById('errors-display');
        const cpmDisplay = document.getElementById('cpm-display');
        const kdphDisplay = document.getElementById('kdph-display');
        const restartButton = document.getElementById('restart-button');
        const settingsButton = document.getElementById('settings-button');
        const mainContent = document.querySelector('.main-content'); // Assuming you have a main content div

        // Progress Bars
        const wpmProgressBar = document.getElementById('wpm-progress-bar-fill');
        const accuracyProgressBar = document.getElementById('accuracy-progress-bar-fill');
        const errorsProgressBar = document.getElementById('errors-progress-bar-fill');
        const cpmProgressBar = document.getElementById('cpm-progress-bar-fill');
        const kdphProgressBar = document.getElementById('kdph-progress-bar-fill');
        const timeProgressBar = document.getElementById('time-progress-bar-fill');
        const finalConclusionProgressBarFill = document.getElementById('final-conclusion-progress-bar-fill');


        // Settings Overlay Elements
        const settingsOverlay = document.getElementById('settings-overlay');
        const testDurationSelect = document.getElementById('test-duration');
        const targetWpmInput = document.getElementById('target-wpm');
        const targetAccuracyInput = document.getElementById('target-accuracy');
        const storyTypeSelect = document.getElementById('story-type');
        const customStoryArea = document.getElementById('custom-story-area');
        const customStoryTextarea = document.getElementById('custom-story-textarea');
        const saveSettingsButton = document.getElementById('save-settings-button');
        const skipSettingsButton = document.getElementById('skip-settings-button');
        const fontSelect = document.getElementById('font-select'); // Font selection element
        const krutidevWarning = document.getElementById('krutidev-warning'); // Kruti Dev warning element
        const addStoryLinkButton = document.getElementById('add-story-link-button');


        // Result Modal Elements
        const resultModal = document.getElementById('result-modal');
        const finalWpmDisplay = document.getElementById('final-wpm-display');
        const rawWPMDisplay = document.getElementById('raw-wpm-display');
        const finalAccuracyDisplay = document.getElementById('final-accuracy-display');
        const finalErrorsDisplay = document.getElementById('final-errors-display');
        const finalCpmDisplay = document.getElementById('final-cpm-display');
        const finalKdphDisplay = document.getElementById('final-kdph-display');

        const errIncorrectChars = document.getElementById('err-incorrect-chars');
        const errMissedChars = document.getElementById('err-missed-chars');
        const errExtraChars = document.getElementById('err-extra-chars');
        const errSkippedWords = document.getElementById('err-skipped-words');
        const errExtraWords = document.getElementById('err-extra-words');
        const errIncorrectEnter = document.getElementById('err-incorrect-enter');
        const errIncorrectSpace = document.getElementById('err-incorrect-space');

        const wpmTargetStatus = document.getElementById('wpm-target-status');
        const accuracyTargetStatus = document.getElementById('accuracy-target-status');

        const modalRestartButton = document.getElementById('modal-restart-button');
        const modalSettingsButton = document.getElementById('modal-settings-button');


        // --- Utility Functions ---

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        function setProgressBar(element, percentage) {
            element.style.width = `${Math.min(100, Math.max(0, percentage))}%`;
        }

        function applyFont(fontName) {
            // Remove all font classes first to ensure only one is applied
            testArea.classList.remove('font-mangal', 'font-krutidev', 'font-hind', 'font-noto');
            typingInput.classList.remove('font-mangal', 'font-krutidev', 'font-hind', 'font-noto');

            switch (fontName) {
                case 'Mangal':
                    testArea.classList.add('font-mangal');
                    typingInput.classList.add('font-mangal');
                    break;
                case 'Kruti Dev 010':
                    testArea.classList.add('font-krutidev');
                    typingInput.classList.add('font-krutidev');
                    krutidevWarning.classList.add('show');
                    break;
                case 'Hind Siliguri':
                    testArea.classList.add('font-hind');
                    typingInput.classList.add('font-hind');
                    break;
                case 'Noto Sans Devanagari':
                default:
                    testArea.classList.add('font-noto');
                    typingInput.classList.add('font-noto');
                    break;
            }
            // Hide Kruti Dev warning if another font is selected
            if (fontName !== 'Kruti Dev 010') {
                krutidevWarning.classList.remove('show');
            }
        }

        // --- Story Fetching (Placeholder, replace with actual API calls if needed) ---

        async function fetchAIGeneratedStory(lengthCategory) {
            // This is a placeholder. In a real application, you'd fetch from an API.
            // For now, it returns fixed Hindi text.
            let stories = {
                'short': [
                    "एक बार की बात है, एक जंगल में एक शेर रहता था। वह बहुत शक्तिशाली था और सभी जानवर उससे डरते थे। एक दिन, शेर को एक छोटा चूहा मिला। शेर ने चूहे को खाने का फैसला किया, लेकिन चूहे ने उससे दया की भीख मांगी। चूहे ने कहा कि वह शेर के काम आ सकता है। शेर को हंसी आई, लेकिन उसने चूहे को जाने दिया।",
                    "सूरज धीरे-धीरे आकाश में उदय हो रहा था, और उसकी सुनहरी किरणें पृथ्वी पर फैल रही थीं। पक्षी चहचहा रहे थे, और हवा में ताज़गी थी। एक किसान अपने खेत की ओर जा रहा था, उसके चेहरे पर शांति और संतुष्टि थी। वह जानता था कि एक नया दिन नई उम्मीदें लेकर आया है।",
                    "बारिश की बूँदें खिड़की से टकरा रही थीं, और अंदर एक आरामदायक गर्माहट थी। एक बच्चा अपनी दादी की गोद में बैठकर कहानी सुन रहा था। कहानी में एक बहादुर राजकुमार और एक जादुई तलवार थी। बच्चे की आँखें चमक रही थीं, क्योंकि वह हर शब्द को जी रहा था।"
                ],
                'medium': [
                    "एक छोटे से गाँव में एक साधु रहता था। वह अपनी बुद्धिमत्ता और दयालुता के लिए जाना जाता था। लोग दूर-दूर से उसकी सलाह लेने आते थे। एक बार, एक धनी व्यापारी उसके पास आया और पूछा, 'जीवन का अर्थ क्या है?' साधु मुस्कुराया और कहा, 'जीवन का अर्थ खोजने में नहीं, बल्कि उसे जीने में है। हर पल को जियो, और तुम्हें अर्थ मिल जाएगा।' व्यापारी ने साधु की बात पर विचार किया और एक नया दृष्टिकोण प्राप्त किया। उसने अपने धन का उपयोग दूसरों की मदद करने के लिए करना शुरू कर दिया, और उसे सच्ची खुशी मिली।",
                    "प्राचीन काल में, एक राजा था जिसने अपने राज्य को बहुत समृद्ध बनाया। उसके पास एक विशाल सेना और अद्भुत खजाने थे। लेकिन राजा हमेशा चिंतित रहता था कि कोई उसके राज्य पर हमला न कर दे। एक दिन, एक बुद्धिमान गुरु उसके महल में आए। राजा ने उनसे पूछा, 'मैं अपने मन की शांति कैसे पा सकता हूँ?' गुरु ने उत्तर दिया, 'सच्ची शांति बाहर नहीं, बल्कि तुम्हारे अंदर है। जब तुम अपनी इच्छाओं और भय को त्याग दोगे, तब तुम्हें शांति मिलेगी।' राजा ने गुरु के शब्दों का पालन किया और अंततः उसे सच्ची शांति और खुशी मिली।"
                ],
                'long': [
                    "हिमालय की ऊँची चोटियों पर, एक छोटा सा मठ था जहाँ एक युवा भिक्षु तपस्या कर रहा था। उसका नाम आनंद था, और वह ज्ञान की खोज में था। कई वर्षों तक उसने ध्यान किया, लेकिन उसे लगा कि कुछ गायब है। एक दिन, एक बूढ़ा यात्री मठ में आया। उसने आनंद को देखा और मुस्कुराया। यात्री ने कहा, 'ज्ञान केवल ग्रंथों में नहीं मिलता, बल्कि जीवन के अनुभवों में भी है। जाओ, दुनिया देखो, लोगों से मिलो, और तुम सच को पाओगे।' आनंद ने यात्री की सलाह मानी और अपनी यात्रा पर निकल पड़ा। उसने कई गाँवों और शहरों का दौरा किया, विभिन्न संस्कृतियों के लोगों से मिला, और जीवन के हर पहलू से सीखा। उसने गरीबी और धन, खुशी और दुख, प्रेम और हानि का अनुभव किया। इन अनुभवों ने उसे सच्ची समझ दी, और उसे एहसास हुआ कि जीवन का सबसे बड़ा ज्ञान स्वयं जीवन में ही निहित है। जब वह मठ लौटा, तो वह एक प्रबुद्ध व्यक्ति बन चुका था, और उसने दूसरों को भी अपने ज्ञान से लाभान्वित किया। उसकी कहानी दूर-दूर तक फैल गई, और लोग उसकी बुद्धिमत्ता और दयालुता के लिए उसे पूजने लगे।",
                    "एक समय की बात है, एक जादुई जंगल था जहाँ पेड़ बात कर सकते थे और जानवर गाना गा सकते थे। जंगल के बीच में एक प्राचीन वृक्ष था, जिसे जीवन का वृक्ष कहा जाता था। इसकी जड़ें पृथ्वी में गहराई तक फैली हुई थीं, और इसकी शाखाएँ आकाश को छूती थीं। एक युवा लड़की, जिसका नाम लीला था, जंगल में रहती थी। वह बहुत साहसी और जिज्ञासु थी। एक दिन, उसे जीवन के वृक्ष के बारे में एक रहस्य पता चला। कहा जाता था कि जो कोई भी उसके फलों को खाएगा, वह अमर हो जाएगा। लीला ने फलों की तलाश करने का फैसला किया, लेकिन जंगल के संरक्षक, एक बूढ़े उल्लू ने उसे चेतावनी दी। उल्लू ने कहा, 'अमरता एक आशीर्वाद नहीं, बल्कि एक अभिशाप हो सकती है। जीवन का चक्र महत्वपूर्ण है।' लीला ने उल्लू की बात नहीं मानी और फलों को खा लिया। शुरुआत में, वह खुशी थी, लेकिन जल्द ही उसे एहसास हुआ कि अमरता का मतलब हमेशा के लिए अकेले रहना है, जबकि उसके प्रियजन बूढ़े होकर मर जाते हैं। उसने अपनी गलती का एहसास किया और उल्लू से मदद मांगी। उल्लू ने उसे एक जादुई मंत्र बताया जिससे वह अपनी अमरता को त्याग सकती थी। लीला ने मंत्र का जाप किया, और उसे फिर से नश्वरता मिल गई। उसने खुशी-खुशी अपने जीवन को जिया, और उसने अमरता के बजाय जीवन की सुंदरता को महत्व दिया।"
                ],
                'random-words': [
                    "भारत विज्ञान अंतरिक्ष यात्रा प्रौद्योगिकी भविष्य विकास शिक्षा ज्ञान कौशल महत्वपूर्ण",
                    "प्रकृति जंगल पहाड़ नदियाँ जीवन पशु पक्षी पर्यावरण संरक्षण जलवायु परिवर्तन",
                    "शहर लोग भीड़ यातायात इमारतें सड़कें आवागमन संस्कृति विविधता शहरीकरण",
                    "किताबें पढ़ना कहानी उपन्यास साहित्य कविता नाटक लेखन मनोरंजन ज्ञान",
                    "स्वास्थ्य भोजन पोषण व्यायाम योग ध्यान शांति मन शरीर आत्मा संतुलन",
                    "दोस्ती प्यार संबंध परिवार समाज सहयोग समर्थन विश्वास एकजुटता समुदाय",
                    "संगीत नृत्य कला चित्रकला मूर्तिकला रचनात्मकता अभिव्यक्ति प्रेरणा सौंदर्य",
                    "अर्थव्यवस्था व्यापार वाणिज्य उद्योग उत्पादन उपभोक्ता बाजार प्रतिस्पर्धा",
                    "राजनीति सरकार कानून न्याय लोकतंत्र चुनाव नागरिक अधिकार कर्तव्य",
                    "धर्म अध्यात्म पूजा प्रार्थना ध्यान मोक्ष शांति आत्मा परमात्मा"
                ]
            };

            if (lengthCategory === 'ai-story') { // Fallback if called directly without a specific length
                lengthCategory = 'medium';
            }

            const categoryStories = stories[lengthCategory] || stories['random-words'];
            const randomIndex = Math.floor(Math.random() * categoryStories.length);
            return categoryStories[randomIndex];
        }


        // --- Test Logic Functions ---

        async function generateAndRenderTestWords() {
            testWords = [];
            testArea.innerHTML = '';
            totalExpectedCharsInTest = 0;

            let textToType = "";

            if (currentStoryType === 'ai-story') {
                let lengthCategory = 'medium';
                const durationMinutes = parseInt(testDurationSelect.value);
                if (durationMinutes <= 2) {
                    lengthCategory = 'short';
                } else if (durationMinutes >= 10) {
                    lengthCategory = 'long';
                }
                textToType = await fetchAIGeneratedStory(lengthCategory);
            } else if (currentStoryType === 'user-custom') {
                textToType = customStoryText.trim();
                if (textToType === "") {
                    alert("कृपया टेक्स्ट एरिया में अपनी कस्टम कहानी पेस्ट करें या कोई अन्य कहानी प्रकार चुनें।");
                    settingsOverlay.classList.add('show');
                    mainContent.classList.add('content-hidden');
                    return false;
                }
            } else {
                textToType = await fetchAIGeneratedStory('random-words');
            }

            const paragraphs = textToType.split(/\r?\n/);

            paragraphs.forEach((paragraphText, paraIdx) => {
                const paragraphDiv = document.createElement('div');
                paragraphDiv.classList.add('paragraph');

                // Split words in a paragraph by one or more spaces
                const wordsWithSpaces = paragraphText.match(/\S+\s*|\s+/g) || [];

                wordsWithSpaces.forEach((item) => {
                    if (item.trim() === '') {
                        // If it's just spaces, treat as part of the word's trailing spaces
                        totalExpectedCharsInTest += item.length;
                    } else {
                        const actualWord = item.trim();
                        testWords.push(actualWord);
                        totalExpectedCharsInTest += actualWord.length;

                        const wordSpan = document.createElement('span');
                        wordSpan.classList.add('word');
                        actualWord.split('').forEach(char => {
                            const charSpan = document.createElement('span');
                            charSpan.textContent = char;
                            charSpan.classList.add('untyped');
                            wordSpan.appendChild(charSpan);
                        });

                        const trailingSpaces = item.substring(actualWord.length);
                        for (let i = 0; i < trailingSpaces.length; i++) {
                            const charSpan = document.createElement('span');
                            charSpan.textContent = trailingSpaces[i];
                            charSpan.classList.add('untyped');
                            wordSpan.appendChild(charSpan);
                        }
                        totalExpectedCharsInTest += trailingSpaces.length;

                        paragraphDiv.appendChild(wordSpan);
                    }
                });

                if (paraIdx < paragraphs.length - 1) {
                    const newlineMarker = document.createElement('span');
                    newlineMarker.classList.add('newline-marker');
                    paragraphDiv.appendChild(newlineMarker);

                    testWords.push('\n'); // Add newline as a distinct item for logic
                    totalExpectedCharsInTest++; // Count newline marker as a character
                }

                testArea.appendChild(paragraphDiv);
            });

            highlightCurrentWord();
            adjustTestAreaScroll();
            updateAllProgressBars(); // Initialize all progress bars
            return true;
        }

        function getDomElementForTestItem(targetIndex) {
            let currentTraversalIndex = 0;
            const paragraphs = testArea.querySelectorAll('.paragraph');

            for (let i = 0; i < paragraphs.length; i++) {
                const paragraphDiv = paragraphs[i];
                const children = Array.from(paragraphDiv.children);

                for (let j = 0; j < children.length; j++) {
                    const child = children[j];
                    if (currentTraversalIndex === targetIndex) {
                        return child;
                    }
                    currentTraversalIndex++;
                }
            }
            return null;
        }

        function highlightCurrentWord() {
            testArea.querySelectorAll('.word').forEach(span => {
                span.classList.remove('current-word');
            });
            testArea.querySelectorAll('.newline-marker').forEach(marker => {
                marker.classList.remove('current-newline-marker');
            });

            if (wordIndex >= testWords.length) {
                adjustTestAreaScroll();
                return;
            }

            const currentItem = testWords[wordIndex];
            const currentDomElement = getDomElementForTestItem(wordIndex);

            if (currentItem === '\n') {
                if (currentDomElement && currentDomElement.classList.contains('newline-marker')) {
                    currentDomElement.classList.add('current-newline-marker');
                    adjustTestAreaScroll();
                }
            } else if (currentDomElement && currentDomElement.classList.contains('word')) {
                currentDomElement.classList.add('current-word');
                adjustTestAreaScroll();
            }
        }

        function adjustTestAreaScroll() {
            const currentDomElement = getDomElementForTestItem(wordIndex);
            if (!currentDomElement) return;

            const testAreaRect = testArea.getBoundingClientRect();
            const targetRect = currentDomElement.getBoundingClientRect();

            // Scroll down if current word is below the visible area
            if (targetRect.bottom > testAreaRect.bottom) {
                testArea.scrollTop += (targetRect.bottom - testAreaRect.bottom) + 10;
            }
            // Scroll up if current word is above the visible area
            else if (targetRect.top < testAreaRect.top) {
                testArea.scrollTop -= (testAreaRect.top - targetRect.top) + 10;
            }
        }

        function updateAllProgressBars() {
            const timeElapsed = (defaultTestDuration - timeLeft);
            const minutesElapsed = timeElapsed / 60;
            const hoursElapsed = timeElapsed / 3600;

            const currentWPM = Math.max(0, ((correctChars - (errors.incorrectChars + errors.missedChars + errors.extraChars + (errors.skippedWords * 5) + (errors.extraWords * 5) + errors.incorrectEnter + errors.incorrectSpace)) / 5) / (minutesElapsed || 1));
            const currentAccuracy = totalTypedChars === 0 ? 0 : Math.round((correctChars / totalTypedChars) * 100);
            const totalErrors = errors.incorrectChars + errors.missedChars + errors.extraChars + errors.skippedWords + errors.extraWords + errors.incorrectEnter + errors.incorrectSpace;
            const currentCPM = correctChars / (minutesElapsed || 1);
            const currentKDPH = correctChars / (hoursElapsed || 1);


            // Update highest WPM, CPM, KDPH for better scaling if current value exceeds previous highest
            if (currentWPM > highestWPM) highestWPM = currentWPM;
            if (currentCPM > highestCPM) highestCPM = currentCPM;
            if (currentKDPH > highestKDPH) highestKDPH = currentKDPH;

            // WPM Progress Bar
            const maxWPMForScale = Math.max(100, highestWPM + 20); // Add a buffer for better visual range
            let wpmProgress = (currentWPM / maxWPMForScale) * 100;
            setProgressBar(wpmProgressBar, wpmProgress);

            // Accuracy Progress Bar (0-100%)
            setProgressBar(accuracyProgressBar, currentAccuracy);

            // Errors Progress Bar (More errors = wider bar)
            const maxErrorsForScale = Math.max(50, totalExpectedCharsInTest * 0.15); // e.g., 15% of expected chars
            const errorProgress = (totalErrors / maxErrorsForScale) * 100;
            setProgressBar(errorsProgressBar, errorProgress);

            // CPM Progress Bar
            const maxCPMForScale = Math.max(500, highestCPM + 100);
            let cpmProgress = (currentCPM / maxCPMForScale) * 100;
            setProgressBar(cpmProgressBar, cpmProgress);

            // KDPH Progress Bar
            const maxKDPHForScale = Math.max(5000, highestKDPH + 500);
            let kdphProgress = (currentKDPH / maxKDPHForScale) * 100;
            setProgressBar(kdphProgressBar, kdphProgress);

            // Time Left Progress Bar (100%-0%)
            const timeLeftPercentage = (timeLeft / defaultTestDuration) * 100;
            setProgressBar(timeProgressBar, timeLeftPercentage);
        }


        function updateStats() {
            const timeElapsed = (defaultTestDuration - timeLeft);
            if (!isTestRunning || timeElapsed === 0) {
                wpmDisplay.textContent = 0;
                accuracyDisplay.textContent = 0;
                errorsDisplay.textContent = errors.incorrectChars + errors.missedChars + errors.extraChars + errors.skippedWords + errors.extraWords + errors.incorrectEnter + errors.incorrectSpace;
                cpmDisplay.textContent = 0;
                kdphDisplay.textContent = 0;
                updateAllProgressBars();
                return;
            }

            const minutesElapsed = timeElapsed / 60;
            const hoursElapsed = timeElapsed / 3600;

            const totalCalculatedErrors = errors.incorrectChars + errors.missedChars + errors.extraChars +
                                        (errors.skippedWords * 5) + (errors.extraWords * 5) + errors.incorrectEnter + errors.incorrectSpace;


            const netWPM = ((correctChars - totalCalculatedErrors) / 5) / minutesElapsed;
            wpmDisplay.textContent = Math.max(0, Math.round(netWPM));

            const currentCPM = correctChars / minutesElapsed;
            cpmDisplay.textContent = isNaN(currentCPM) ? 0 : Math.round(currentCPM);

            const currentKDPH = (correctChars / hoursElapsed);
            kdphDisplay.textContent = isNaN(currentKDPH) ? 0 : Math.round(currentKDPH);


            const currentAccuracy = totalTypedChars === 0 ? 0 : Math.round((correctChars / totalTypedChars) * 100);
            accuracyDisplay.textContent = isNaN(currentAccuracy) ? 0 : currentAccuracy;

            errorsDisplay.textContent = totalCalculatedErrors;

            updateAllProgressBars();
        }

        function startTimer() {
            startTime = Date.now();
            isTestRunning = true;
            timerInterval = setInterval(() => {
                timeLeft--;
                countdownDisplay.textContent = formatTime(timeLeft);
                updateStats();

                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    endTest();
                }
            }, 1000);
        }

        function endTest() {
            isTestRunning = false;
            typingInput.disabled = true;
            typingInput.value = '';
            clearInterval(timerInterval);

            // Calculate remaining skipped words/newlines for the final stats
            for (let i = wordIndex; i < testWords.length; i++) {
                if (testWords[i] !== '\n') {
                    errors.skippedWords++;
                } else {
                    errors.missedChars++; // Count newline marker as a missed character if not typed
                }
            }


            updateStats(); // Final update to live stats before modal shows

            const timeElapsed = (defaultTestDuration - timeLeft);
            const finalMinutesElapsed = timeElapsed / 60;
            const finalHoursElapsed = timeElapsed / 3600;

            if (finalMinutesElapsed === 0) {
                 finalWpmDisplay.textContent = 0;
                 finalAccuracyDisplay.textContent = 0;
                 finalErrorsDisplay.textContent = 0;
                 rawWPMDisplay.textContent = 0;
                 finalCpmDisplay.textContent = 0;
                 finalKdphDisplay.textContent = 0;
            } else {
                const totalCalculatedErrors = errors.incorrectChars + errors.missedChars + errors.extraChars +
                                            (errors.skippedWords * 5) + (errors.extraWords * 5) + errors.incorrectEnter + errors.incorrectSpace;

                const finalNetWPM = Math.max(0, ((correctChars - totalCalculatedErrors) / 5) / finalMinutesElapsed);
                finalWpmDisplay.textContent = Math.round(finalNetWPM);

                const finalRawWPM = (totalTypedChars / 5) / finalMinutesElapsed;
                rawWPMDisplay.textContent = Math.round(finalRawWPM);

                const finalAccuracy = totalTypedChars === 0 ? 0 : Math.round((correctChars / totalTypedChars) * 100);
                finalAccuracyDisplay.textContent = finalAccuracy;

                const finalCPM = correctChars / finalMinutesElapsed;
                finalCpmDisplay.textContent = Math.round(finalCPM);

                const finalKDPH = correctChars / finalHoursElapsed;
                finalKdphDisplay.textContent = Math.round(finalKDPH);

                finalErrorsDisplay.textContent = totalCalculatedErrors;
            }

            errIncorrectChars.textContent = errors.incorrectChars;
            errMissedChars.textContent = errors.missedChars;
            errExtraChars.textContent = errors.extraChars;
            errSkippedWords.textContent = errors.skippedWords;
            errExtraWords.textContent = errors.extraWords;
            errIncorrectEnter.textContent = errors.incorrectEnter;
            errIncorrectSpace.textContent = errors.incorrectSpace;


            finalWpmDisplay.className = 'result-value result-value-green';
            finalAccuracyDisplay.className = 'result-value result-value-green';
            finalErrorsDisplay.className = 'result-value result-value-red';
            rawWPMDisplay.className = 'result-value result-value-purple';
            finalCpmDisplay.className = 'result-value result-value-orange';
            finalKdphDisplay.className = 'result-value result-value-kdph';

            // Final Conclusion Progress Bar (a weighted average of WPM and Accuracy, penalizing errors)
            let wpmScore = parseFloat(finalWpmDisplay.textContent);
            let accuracyScore = parseFloat(finalAccuracyDisplay.textContent);
            let totalErrors = parseFloat(finalErrorsDisplay.textContent);

            // Normalize scores to a 0-100 range for the final bar
            // Assuming a good WPM is 40-60, excellent is 80+, so scale WPM towards 100
            let normalizedWPM = (wpmScore / 60) * 100; // Aiming for 60 WPM as a benchmark for 100% WPM score
            normalizedWPM = Math.min(100, Math.max(0, normalizedWPM)); // Clamp between 0 and 100

            let normalizedAccuracy = accuracyScore;

            // Penalty for errors: e.g., 1 point deduction for every 5 errors (adjustable)
            let errorPenalty = (totalErrors / 5) * 1;
            errorPenalty = Math.min(50, errorPenalty); // Cap penalty to prevent negative scores

            let finalConclusionProgress = (normalizedWPM * 0.6) + (normalizedAccuracy * 0.4) - errorPenalty; // Weighted average
            finalConclusionProgress = Math.max(0, Math.min(100, finalConclusionProgress)); // Cap between 0 and 100

            // Apply the single color for the final bar
            setProgressBar(finalConclusionProgressBarFill, finalConclusionProgress);


            // Check and update target status
            if (userTargetWPM !== null && !isNaN(userTargetWPM)) {
                if (parseFloat(finalWpmDisplay.textContent) >= userTargetWPM) {
                    wpmTargetStatus.querySelector('p:last-child').textContent = `प्राप्त (${userTargetWPM} WPM)`;
                    wpmTargetStatus.querySelector('p:last-child').className = 'status-met';
                } else {
                    wpmTargetStatus.querySelector('p:last-child').textContent = `प्राप्त नहीं (${userTargetWPM} WPM)`;
                    wpmTargetStatus.querySelector('p:last-child').className = 'status-not-met';
                }
            } else {
                wpmTargetStatus.querySelector('p:last-child').textContent = 'लागू नहीं';
                wpmTargetStatus.querySelector('p:last-child').className = 'status-neutral';
            }

            if (userTargetAccuracy !== null && !isNaN(userTargetAccuracy)) {
                if (parseFloat(finalAccuracyDisplay.textContent) >= userTargetAccuracy) {
                    accuracyTargetStatus.querySelector('p:last-child').textContent = `प्राप्त (${userTargetAccuracy}%)`;
                    accuracyTargetStatus.querySelector('p:last-child').className = 'status-met';
                } else {
                    accuracyTargetStatus.querySelector('p:last-child').textContent = `प्राप्त नहीं (${userTargetAccuracy}%)`;
                    accuracyTargetStatus.querySelector('p:last-child').className = 'status-not-met';
                }
            } else {
                accuracyTargetStatus.querySelector('p:last-child').textContent = 'लागू नहीं';
                accuracyTargetStatus.querySelector('p:last-child').className = 'status-neutral';
            }

            // Ensure the result modal is shown.
            resultModal.classList.add('show');
            mainContent.classList.add('content-hidden');


            restartButton.disabled = false;
            settingsButton.disabled = false;
        }

        async function initializeTest(duration, targetWPM, targetAccuracy, storyType, customText = '', font = 'Noto Sans Devanagari') {
            clearInterval(timerInterval);
            defaultTestDuration = duration * 60;
            timeLeft = defaultTestDuration;
            countdownDisplay.textContent = formatTime(timeLeft);
            wordIndex = 0;
            charIndex = 0;
            correctChars = 0;
            totalTypedChars = 0;
            totalExpectedCharsInTest = 0;
            errors = {
                incorrectChars: 0,
                missedChars: 0,
                extraChars: 0,
                skippedWords: 0,
                extraWords: 0,
                incorrectEnter: 0,
                incorrectSpace: 0
            };
            highestWPM = 0; // Reset highest values
            highestCPM = 0;
            highestKDPH = 0;
            isComposing = false; // Reset composition flag


            typingInput.value = '';
            typingInput.disabled = false;
            startTime = null;
            isTestRunning = false;

            userTargetWPM = targetWPM ? parseInt(targetWPM) : null;
            userTargetAccuracy = targetAccuracy ? parseInt(targetAccuracy) : null;
            currentStoryType = storyType;
            customStoryText = customText;
            selectedFont = font; // Set the selected font

            wpmDisplay.textContent = '0';
            accuracyDisplay.textContent = '0';
            errorsDisplay.textContent = '0';
            cpmDisplay.textContent = '0';
            kdphDisplay.textContent = '0';

            // Reset all progress bars visually to 0% and their initial (or appropriate) fill
            setProgressBar(wpmProgressBar, 0);
            setProgressBar(accuracyProgressBar, 0);
            setProgressBar(errorsProgressBar, 0);
            setProgressBar(cpmProgressBar, 0);
            setProgressBar(kdphProgressBar, 0);
            setProgressBar(timeProgressBar, 100); // Time starts full

            restartButton.disabled = false;
            settingsButton.disabled = false;

            applyFont(selectedFont); // Apply the selected font

            const generationSuccess = await generateAndRenderTestWords();
            if (!generationSuccess) {
                return;
            }

            typingInput.focus();
            resultModal.classList.remove('show'); // Ensure it's hidden before starting new test
            settingsOverlay.classList.remove('show');
            mainContent.classList.remove('content-hidden');
        }


        // Event Listeners

        typingInput.addEventListener('compositionstart', () => {
            isComposing = true;
        });

        typingInput.addEventListener('compositionend', () => {
            isComposing = false;
            // Trigger input processing if composition has ended and there's text
            if (typingInput.value.length > 0) {
                processInput();
            }
        });

        typingInput.addEventListener('input', (e) => {
            if (!isTestRunning && startTime === null) {
                startTimer();
            }
            // Only process input directly if not composing
            if (!isComposing) {
                processInput();
            }
        });

        function processInput() {
            const currentExpectedItem = testWords[wordIndex];
            const typedText = typingInput.value;

            if (!currentExpectedItem) return; // Test might have ended

            if (currentExpectedItem === '\n') {
                // If expecting a newline, and user types something, clear input
                // This prevents typing into the story text if the system doesn't auto-handle enter
                if (typedText.length > 0) {
                    typingInput.value = ''; // Clear input if user types instead of pressing Enter for newline
                }
                return;
            }

            const currentWordSpan = getDomElementForTestItem(wordIndex);

            if (!currentWordSpan || !currentWordSpan.classList.contains('word')) {
                return;
            }
            const currentWordExpected = currentExpectedItem; // Define here for clarity

            const charSpans = Array.from(currentWordSpan.querySelectorAll('span'));

            // Reset classes for current word's characters
            charSpans.forEach(span => {
                span.classList.remove('correct', 'incorrect', 'extra');
                span.classList.add('untyped');
                span.style.display = 'inline';
            });

            // Remove previous extra characters
            currentWordSpan.querySelectorAll('.extra').forEach(el => el.remove());

            // Add new extra characters
            if (typedText.length > currentWordExpected.length) {
                for (let i = currentWordExpected.length; i < typedText.length; i++) {
                    const extraSpan = document.createElement('span');
                    extraSpan.textContent = typedText[i];
                    extraSpan.classList.add('extra');
                    currentWordSpan.appendChild(extraSpan);
                }
            }


            // Mark characters as correct/incorrect
            // This loop should run after adding extra spans, to ensure it doesn't affect existing chars
            let newCorrectCharsCount = 0; // Track correct chars for current typed segment only
            for (let i = 0; i < currentWordExpected.length; i++) {
                const charExpected = currentWordExpected[i];
                const typedChar = typedText[i];
                const charSpan = charSpans[i];

                if (charSpan) {
                    if (typedChar === undefined) {
                        charSpan.classList.add('untyped');
                    } else if (typedChar === charExpected) {
                        charSpan.classList.add('correct');
                        newCorrectCharsCount++;
                    } else {
                        charSpan.classList.add('incorrect');
                    }
                }
            }

            // Update charIndex based on current input length
            charIndex = typedText.length;

            updateStats();
        }


        typingInput.addEventListener('keydown', (e) => {
            if (!isTestRunning && startTime === null) {
                startTimer();
            }

            // If a composition is in progress (e.g., swiping on mobile), don't process keydown events directly
            // Wait for 'compositionend' to finalize the input.
            if (isComposing) {
                return;
            }

            const currentExpectedItem = testWords[wordIndex];
            const typedText = typingInput.value;

            // Handle Spacebar
            if (e.key === ' ' || e.keyCode === 32 || e.which === 32) {
                e.preventDefault(); // Prevent default space behavior

                // If expecting a newline, and user presses space, it's an incorrect space
                if (currentExpectedItem === '\n') {
                    errors.incorrectSpace++;
                    totalTypedChars++; // Count the space as a typed character
                    typingInput.value = ''; // Clear input for next word
                    updateStats();
                    return; // Do not advance wordIndex here
                }

                // Process the word typed before the space
                const currentWordExpected = currentExpectedItem;
                let wordTyped = typedText;

                let wordCorrectCharsCount = 0;

                for (let i = 0; i < Math.max(currentWordExpected.length, wordTyped.length); i++) {
                    const expectedChar = currentWordExpected[i];
                    const typedChar = wordTyped[i];

                    if (typedChar === undefined) { // Missed character in expected word
                        errors.missedChars++;
                    } else if (expectedChar === undefined) { // Extra character typed by user
                        errors.extraChars++;
                    } else if (typedChar !== expectedChar) { // Incorrect character typed
                        errors.incorrectChars++;
                    } else { // Correct character
                        wordCorrectCharsCount++;
                    }
                }

                correctChars += wordCorrectCharsCount;
                totalTypedChars += wordTyped.length;
                totalTypedChars++; // Count the space itself as a typed character

                wordIndex++; // Move to the next word/item
                typingInput.value = ''; // Clear input for next word
                charIndex = 0;
                highlightCurrentWord();

                if (wordIndex >= testWords.length) {
                    endTest();
                }
                updateStats();

            // Handle Enter Key
            } else if (e.key === 'Enter' || e.keyCode === 13 || e.which === 13) {
                e.preventDefault(); // Prevent default Enter behavior (e.g., new line in input)

                if (currentExpectedItem === '\n') {
                    // If user typed anything before pressing enter for a newline, count as incorrect chars
                    if (typedText.length > 0) {
                        errors.incorrectChars += typedText.length;
                        totalTypedChars += typedText.length;
                    }

                    correctChars++; // Count the correct 'Enter' as a correct character
                    totalTypedChars++; // Count the 'Enter' as a typed character

                    wordIndex++; // Move to the next word/item
                    typingInput.value = ''; // Clear input
                    charIndex = 0;
                    highlightCurrentWord();

                    if (wordIndex >= testWords.length) {
                        endTest();
                    }
                } else {
                    // If not expecting a newline but user presses Enter, it's an incorrect enter
                    errors.incorrectEnter++;
                    totalTypedChars++; // Count the 'Enter' as a typed character
                }
                updateStats();
            } else if (e.key === 'Backspace') {
                // Allow backspace to modify the typed text
                if (charIndex > 0) {
                    charIndex--;
                }
                // The 'input' event listener will handle the visual update after backspace
            }
        });

        // Add an event listener for when the input field loses focus
        typingInput.addEventListener('blur', () => {
            if (isTestRunning && typingInput.value.length > 0) {
                // If there's text in the input field and the test is running,
                // simulate a spacebar press to process the current word.
                // This is a fallback for mobile keyboards that might not trigger 'keydown' for space.
                const currentExpectedItem = testWords[wordIndex];
                if (currentExpectedItem && currentExpectedItem !== '\n') { // Only process if it's a word
                    // Simulate processing of the current word
                    let wordTyped = typingInput.value;
                    let currentWordExpected = currentExpectedItem;

                    let wordCorrectCharsCount = 0;
                    for (let i = 0; i < Math.max(currentWordExpected.length, wordTyped.length); i++) {
                        const expectedChar = currentWordExpected[i];
                        const typedChar = wordTyped[i];

                        if (typedChar === undefined) {
                            errors.missedChars++;
                        } else if (expectedChar === undefined) {
                            errors.extraChars++;
                        } else if (typedChar !== expectedChar) {
                            errors.incorrectChars++;
                        } else {
                            wordCorrectCharsCount++;
                        }
                    }

                    correctChars += wordCorrectCharsCount;
                    totalTypedChars += wordTyped.length;
                    totalTypedChars++; // Count the implied space/end-of-word

                    wordIndex++;
                    typingInput.value = '';
                    charIndex = 0;
                    highlightCurrentWord();

                    if (wordIndex >= testWords.length) {
                        endTest();
                    }
                    updateStats();
                }
            }
        });


        restartButton.addEventListener('click', () => {
            settingsOverlay.classList.add('show');
            resultModal.classList.remove('show');
            mainContent.classList.add('content-hidden');
            testDurationSelect.value = defaultTestDuration / 60;
            targetWpmInput.value = userTargetWPM || '';
            targetAccuracyInput.value = userTargetAccuracy || '';
            storyTypeSelect.value = currentStoryType;
            fontSelect.value = selectedFont; // Set current font in settings
            if (currentStoryType === 'user-custom') {
                customStoryArea.style.display = 'block';
                customStoryTextarea.value = customStoryText;
            } else {
                customStoryArea.style.display = 'none';
            }
            if (selectedFont === 'Kruti Dev 010') {
                krutidevWarning.classList.add('show');
            } else {
                krutidevWarning.classList.remove('show');
            }
        });

        settingsButton.addEventListener('click', () => {
            settingsOverlay.classList.add('show');
            mainContent.classList.add('content-hidden');
            testDurationSelect.value = defaultTestDuration / 60;
            targetWpmInput.value = userTargetWPM || '';
            targetAccuracyInput.value = userTargetAccuracy || '';
            storyTypeSelect.value = currentStoryType;
            fontSelect.value = selectedFont; // Set current font in settings
            if (currentStoryType === 'user-custom') {
                customStoryArea.style.display = 'block';
                customStoryTextarea.value = customStoryText;
            } else {
                customStoryArea.style.display = 'none';
            }
            if (selectedFont === 'Kruti Dev 010') {
                krutidevWarning.classList.add('show');
            } else {
                krutidevWarning.classList.remove('show');
            }
        });

        saveSettingsButton.addEventListener('click', async () => {
            const duration = parseInt(testDurationSelect.value);
            const targetWPM = targetWpmInput.value;
            const targetAccuracy = targetAccuracyInput.value;
            const storyType = storyTypeSelect.value;
            const font = fontSelect.value; // Get selected font
            let storyContent = '';

            if (storyType === 'user-custom') {
                storyContent = customStoryTextarea.value.trim();
            }
            await initializeTest(duration, targetWPM, targetAccuracy, storyType, storyContent, font);
        });

        skipSettingsButton.addEventListener('click', async () => {
            // Default to Noto Sans Devanagari if skipping settings
            await initializeTest(5, null, null, 'random-words', '', 'Noto Sans Devanagari');
        });

        modalRestartButton.addEventListener('click', async () => {
            // Restart with previous settings including font
            await initializeTest(defaultTestDuration / 60, userTargetWPM, userTargetAccuracy, currentStoryType, customStoryText, selectedFont);
        });

        modalSettingsButton.addEventListener('click', () => {
            resultModal.classList.remove('show');
            settingsOverlay.classList.add('show');
            mainContent.classList.add('content-hidden');
            testDurationSelect.value = defaultTestDuration / 60;
            targetWpmInput.value = userTargetWPM || '';
            targetAccuracyInput.value = userTargetAccuracy || '';
            storyTypeSelect.value = currentStoryType;
            fontSelect.value = selectedFont; // Set current font in settings
            if (currentStoryType === 'user-custom') {
                customStoryArea.style.display = 'block';
                customStoryTextarea.value = customStoryText;
            } else {
                customStoryArea.style.display = 'none';
            }
            if (selectedFont === 'Kruti Dev 010') {
                krutidevWarning.classList.add('show');
            } else {
                krutidevWarning.classList.remove('show');
            }
        });

        storyTypeSelect.addEventListener('change', () => {
            if (storyTypeSelect.value === 'user-custom') {
                customStoryArea.style.display = 'block';
            } else {
                customStoryArea.style.display = 'none';
            }
        });

        // New event listener for font selection
        fontSelect.addEventListener('change', () => {
            selectedFont = fontSelect.value;
            if (selectedFont === 'Kruti Dev 010') {
                krutidevWarning.classList.add('show');
            } else {
                krutidevWarning.classList.remove('show');
            }
        });

        addStoryLinkButton.addEventListener('click', () => {
            // Placeholder for a Hindi story source if found
            alert("कृपया हिंदी कहानियों के लिए एक उपयुक्त स्रोत खोजें। Reedsy मुख्य रूप से अंग्रेजी कहानियों के लिए है।"); // Changed to Hindi
            // window.open('https://example.com/hindi-stories', '_blank'); // Replace with actual Hindi source
        });

        // --- Initial Setup on DOM Load ---
        document.addEventListener('DOMContentLoaded', () => {
            settingsOverlay.classList.add('show');
            mainContent.classList.add('content-hidden');
            countdownDisplay.textContent = formatTime(defaultTestDuration);
            customStoryArea.style.display = 'none';
            krutidevWarning.classList.remove('show'); // Hide warning initially
            // Initialize all progress bars to their starting state
            updateAllProgressBars();
            applyFont(selectedFont); // Apply default font on load
        });
    </script>
</body>
</html>
