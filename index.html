<!DOCTYPE html>
<html lang="hi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>हिंदी टाइपिंग टेस्ट</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Hind+Siliguri:wght@400;700&family=Mangal:wght@400;700&family=Noto+Sans+Devanagari:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* General Styles */
        body {
            font-family: 'Noto Sans Devanagari', sans-serif;
            background: #f0f2f5;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent body scroll when overlays are active */
        }

        .container {
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            padding: 30px;
            width: 90%;
            max-width: 900px;
            text-align: center;
            position: relative;
            z-index: 1; /* Ensure main content is below overlays */
        }

        h1 {
            color: #4CAF50;
            margin-bottom: 20px;
        }

        /* Test Area */
        .test-area-wrapper {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            background: #f9f9f9;
            text-align: left;
            position: relative;
            max-height: 200px; /* Limit height */
            overflow-y: auto; /* Enable scrolling */
            line-height: 1.8;
            font-size: 20px;
        }

        .test-area .word {
            display: inline-block; /* Allows individual words to wrap */
            margin-right: 5px; /* Space between words */
            white-space: normal; /* Allow words to wrap within their span if they are too long (unlikely for typical words) */
        }

        .test-area .word:last-child {
            margin-right: 0;
        }

        .test-area span {
            display: inline-block; /* Characters within words */
            transition: background-color 0.1s ease;
        }

        .test-area .current-word {
            background-color: #e0f7fa; /* Highlight current word */
            border-radius: 3px;
        }

        .test-area .current-newline-marker {
            background-color: #ffe0b2; /* Highlight for newline */
            border-radius: 3px;
            padding: 0 5px;
            font-weight: bold;
        }

        .test-area .correct {
            color: #4CAF50;
        }

        .test-area .incorrect {
            color: #f44336;
            background-color: #ffcdd2;
        }

        .test-area .untyped {
            color: #616161;
        }

        .test-area .extra {
            color: #9C27B0; /* Purple for extra characters */
            background-color: #e1bee7;
        }

        .test-area .newline-marker {
            display: inline-block;
            width: 100%; /* Forces a new line */
            height: 1px; /* Minimal height */
            margin: 5px 0; /* Some vertical spacing */
            position: relative;
        }

        .test-area .newline-marker::after {
            content: '⏎'; /* Enter symbol */
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            color: #9e9e9e;
            font-size: 16px;
        }


        /* Input Field */
        .typing-input {
            width: calc(100% - 40px);
            padding: 15px 20px;
            font-size: 24px;
            border: 2px solid #ccc;
            border-radius: 8px;
            margin-bottom: 20px;
            transition: border-color 0.3s ease;
            text-align: left;
        }

        .typing-input:focus {
            border-color: #4CAF50;
            outline: none;
        }

        /* Stats Display */
        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .stat-item {
            background: #e8f5e9;
            padding: 15px;
            border-radius: 8px;
            flex: 1;
            min-width: 120px;
            margin: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        .stat-item p {
            margin: 0;
            font-size: 14px;
            color: #555;
        }

        .stat-item .value {
            font-size: 28px;
            font-weight: bold;
            color: #388E3C;
        }

        .stat-item.time .value { color: #2196F3; } /* Blue for Time */
        .stat-item.accuracy .value { color: #FFC107; } /* Orange for Accuracy */
        .stat-item.errors .value { color: #F44336; } /* Red for Errors */
        .stat-item.cpm .value { color: #FF9800; } /* Orange for CPM */
        .stat-item.kdph .value { color: #9C27B0; } /* Purple for KDPH */

        /* Progress Bars */
        .progress-section {
            margin-bottom: 20px;
        }

        .progress-bar-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 5px;
            height: 10px;
            margin-top: 5px;
            overflow: hidden;
        }

        .progress-bar-fill {
            height: 100%;
            width: 0%;
            border-radius: 5px;
            transition: width 0.3s ease-out;
        }

        .progress-bar-container.wpm .progress-bar-fill { background-color: #4CAF50; }
        .progress-bar-container.accuracy .progress-bar-fill { background-color: #FFC107; }
        .progress-bar-container.errors .progress-bar-fill { background-color: #F44336; }
        .progress-bar-container.cpm .progress-bar-fill { background-color: #FF9800; }
        .progress-bar-container.kdph .progress-bar-fill { background-color: #9C27B0; }
        .progress-bar-container.time .progress-bar-fill { background-color: #2196F3; }


        /* Controls */
        .controls button {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            margin: 0 10px;
            transition: background-color 0.3s ease;
        }

        .controls button:hover {
            background: #0056b3;
        }

        .controls button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }

        /* Settings Overlay */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0s linear 0.3s;
        }

        .overlay.show {
            opacity: 1;
            visibility: visible;
            transition-delay: 0s;
        }

        .overlay-content {
            background: #fff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 500px;
            text-align: left;
            transform: translateY(-20px);
            transition: transform 0.3s ease;
        }

        .overlay.show .overlay-content {
            transform: translateY(0);
        }

        .overlay-content h2 {
            color: #388E3C;
            margin-bottom: 25px;
            text-align: center;
        }

        .settings-group {
            margin-bottom: 20px;
        }

        .settings-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
        }

        .settings-group select,
        .settings-group input[type="number"],
        .settings-group textarea {
            width: calc(100% - 22px);
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }

        .settings-group select:focus,
        .settings-group input[type="number"]:focus,
        .settings-group textarea:focus {
            border-color: #4CAF50;
            outline: none;
        }

        .settings-group textarea {
            resize: vertical;
            min-height: 100px;
        }

        .settings-buttons {
            display: flex;
            justify-content: space-around;
            margin-top: 30px;
        }

        .settings-buttons button {
            background: #28a745;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            transition: background-color 0.3s ease;
        }

        .settings-buttons button.secondary {
            background: #6c757d;
        }

        .settings-buttons button:hover {
            opacity: 0.9;
        }

        /* Result Modal */
        #result-modal .overlay-content {
            max-width: 600px;
        }

        #result-modal h2 {
            color: #4CAF50;
        }

        .result-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .result-row {
            background: #e8f5e9;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        .result-row p {
            margin: 0;
            font-size: 14px;
            color: #555;
        }

        .result-value {
            font-size: 28px;
            font-weight: bold;
            margin-top: 5px;
        }
        .result-value-green { color: #388E3C; }
        .result-value-red { color: #F44336; }
        .result-value-purple { color: #9C27B0; }
        .result-value-orange { color: #FF9800; }
        .result-value-kdph { color: #673AB7; } /* A different purple/indigo for KDPH */

        .error-details {
            text-align: left;
            margin-top: 20px;
            padding: 15px;
            background-color: #ffebee;
            border-radius: 8px;
            border: 1px solid #ef9a9a;
        }

        .error-details h3 {
            color: #F44336;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .error-details p {
            margin: 5px 0;
            font-size: 15px;
            color: #d32f2f;
        }

        .target-status {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #eee;
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 10px;
        }

        .target-status div {
            flex: 1;
            min-width: 150px;
            text-align: center;
            padding: 10px;
            background-color: #f1f8e9;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .target-status p {
            margin: 0;
            font-weight: bold;
        }

        .status-met {
            color: #2E7D32; /* Dark green */
        }

        .status-not-met {
            color: #D32F2F; /* Dark red */
        }

        .status-neutral {
            color: #616161; /* Grey */
        }

        .result-buttons {
            margin-top: 30px;
            display: flex;
            justify-content: space-around;
        }

        .result-buttons button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            transition: background-color 0.3s ease;
        }

        .result-buttons button.secondary {
            background: #007bff;
        }

        .result-buttons button:hover {
            opacity: 0.9;
        }

        /* Font-specific styles */
        .font-mangal {
            font-family: 'Mangal', sans-serif;
        }
        .font-krutidev {
            font-family: 'Kruti Dev 010', sans-serif; /* You'll need to ensure this font is available or linked */
        }
        .font-hind {
            font-family: 'Hind Siliguri', sans-serif;
        }
        .font-noto {
            font-family: 'Noto Sans Devanagari', sans-serif;
        }

        #krutidev-warning {
            background-color: #fff3e0;
            border: 1px solid #ffcc80;
            padding: 10px;
            margin-top: 15px;
            border-radius: 5px;
            color: #e65100;
            font-size: 14px;
            text-align: center;
            display: none; /* Hidden by default */
        }
        #krutidev-warning.show {
            display: block;
        }
        .story-link-button {
            display: block;
            margin-top: 15px;
            background-color: #17a2b8; /* Info blue */
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            width: 100%;
            box-sizing: border-box;
            transition: background-color 0.3s ease;
        }
        .story-link-button:hover {
            background-color: #138496;
        }


        /* Hide main content when an overlay is shown */
        .main-content.content-hidden {
            display: none;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            .stats {
                flex-direction: column;
                align-items: center;
            }
            .stat-item {
                width: 90%;
                margin-bottom: 10px;
            }
            .typing-input {
                font-size: 20px;
            }
            .controls button, .settings-buttons button, .result-buttons button {
                padding: 10px 20px;
                font-size: 16px;
            }
            .settings-buttons, .result-buttons {
                flex-direction: column;
                gap: 15px;
            }
            .settings-buttons button, .result-buttons button {
                width: 100%;
            }
            .result-stats {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>

    <div class="container main-content">
        <h1>हिंदी टाइपिंग टेस्ट</h1>
        <div class="test-area-wrapper">
            <div id="test-area" class="test-area">
                </div>
        </div>

        <input type="text" id="typing-input" class="typing-input" placeholder="टाइपिंग शुरू करें..." autofocus disabled>

        <div class="stats">
            <div class="stat-item time">
                <p>समय</p>
                <span id="countdown" class="value">05:00</span>
            </div>
            <div class="stat-item">
                <p>WPM</p>
                <span id="wpm-display" class="value">0</span>
                <div class="progress-bar-container wpm">
                    <div id="wpm-progress-bar-fill" class="progress-bar-fill"></div>
                </div>
            </div>
            <div class="stat-item accuracy">
                <p>एक्यूरेसी</p>
                <span id="accuracy-display" class="value">0%</span>
                <div class="progress-bar-container accuracy">
                    <div id="accuracy-progress-bar-fill" class="progress-bar-fill"></div>
                </div>
            </div>
            <div class="stat-item errors">
                <p>त्रुटियां</p>
                <span id="errors-display" class="value">0</span>
                <div class="progress-bar-container errors">
                    <div id="errors-progress-bar-fill" class="progress-bar-fill"></div>
                </div>
            </div>
            <div class="stat-item cpm">
                <p>CPM</p>
                <span id="cpm-display" class="value">0</span>
                <div class="progress-bar-container cpm">
                    <div id="cpm-progress-bar-fill" class="progress-bar-fill"></div>
                </div>
            </div>
            <div class="stat-item kdph">
                <p>KDPH</p>
                <span id="kdph-display" class="value">0</span>
                <div class="progress-bar-container kdph">
                    <div id="kdph-progress-bar-fill" class="progress-bar-fill"></div>
                </div>
            </div>
        </div>
        <div class="progress-bar-container time">
            <div id="time-progress-bar-fill" class="progress-bar-fill"></div>
        </div>

        <div class="controls">
            <button id="restart-button">पुनः प्रारंभ करें</button>
            <button id="settings-button">सेटिंग्स</button>
        </div>
    </div>

    <div id="settings-overlay" class="overlay">
        <div class="overlay-content">
            <h2>सेटिंग्स</h2>
            <div class="settings-group">
                <label for="test-duration">समय अवधि (मिनट):</label>
                <select id="test-duration">
                    <option value="1">1 मिनट</option>
                    <option value="2">2 मिनट</option>
                    <option value="5" selected>5 मिनट</option>
                    <option value="10">10 मिनट</option>
                    <option value="15">15 मिनट</option>
                </select>
            </div>
            <div class="settings-group">
                <label for="font-select">फ़ॉन्ट चुनें:</label>
                <select id="font-select">
                    <option value="Noto Sans Devanagari">Noto Sans Devanagari (डिफ़ॉल्ट)</option>
                    <option value="Mangal">मंगल (Mangal)</option>
                    <option value="Kruti Dev 010">कृतिदेव 010 (Kruti Dev 010)</option>
                    <option value="Hind Siliguri">हिंद सिलिगुड़ी (Hind Siliguri)</option>
                </select>
                <p id="krutidev-warning" style="display: none;">**कृतिदेव 010 एक लेगेसी फ़ॉन्ट है। इसमें कुछ अक्षर अलग तरह से टाइप हो सकते हैं।</p>
            </div>
            <div class="settings-group">
                <label for="story-type">कहानी का प्रकार:</label>
                <select id="story-type">
                    <option value="random-words">रैंडम शब्द</option>
                    <option value="ai-story">AI जेनरेटेड कहानी</option>
                    <option value="user-custom">अपनी कस्टम कहानी पेस्ट करें</option>
                </select>
                <div id="custom-story-area" style="display: none; margin-top: 15px;">
                    <label for="custom-story-textarea">अपनी कहानी यहाँ पेस्ट करें:</label>
                    <textarea id="custom-story-textarea" placeholder="अपनी कहानी पेस्ट करें..."></textarea>
                    <button id="add-story-link-button" class="story-link-button">हिंदी कहानियां खोजें</button>
                </div>
            </div>
            <div class="settings-group">
                <label for="target-wpm">लक्ष्य WPM (वैकल्पिक):</label>
                <input type="number" id="target-wpm" placeholder="उदाहरण: 40">
            </div>
            <div class="settings-group">
                <label for="target-accuracy">लक्ष्य एक्यूरेसी (वैकल्पिक %):</label>
                <input type="number" id="target-accuracy" placeholder="उदाहरण: 95">
            </div>
            <div class="settings-buttons">
                <button id="save-settings-button">टेस्ट शुरू करें</button>
                <button id="skip-settings-button" class="secondary">सेटिंग्स छोड़ें</button>
            </div>
        </div>
    </div>

    <div id="result-modal" class="overlay">
        <div class="overlay-content">
            <h2>टेस्ट परिणाम</h2>
            <div class="result-stats">
                <div class="result-row">
                    <p>WPM (शुद्ध)</p>
                    <span id="final-wpm-display" class="result-value result-value-green">0</span>
                </div>
                <div class="result-row">
                    <p>रॉ WPM</p>
                    <span id="raw-wpm-display" class="result-value result-value-purple">0</span>
                </div>
                <div class="result-row">
                    <p>एक्यूरेसी</p>
                    <span id="final-accuracy-display" class="result-value result-value-green">0%</span>
                </div>
                <div class="result-row">
                    <p>कुल त्रुटियां</p>
                    <span id="final-errors-display" class="result-value result-value-red">0</span>
                </div>
                <div class="result-row">
                    <p>CPM (कैरेक्टर प्रति मिनट)</p>
                    <span id="final-cpm-display" class="result-value result-value-orange">0</span>
                </div>
                <div class="result-row">
                    <p>KDPH (की डिप्रेशन प्रति घंटा)</p>
                    <span id="final-kdph-display" class="result-value result-value-kdph">0</span>
                </div>
            </div>
            <div class="progress-bar-container final-conclusion">
                <div id="final-conclusion-progress-bar-fill" class="progress-bar-fill"></div>
            </div>

            <div class="target-status">
                <div id="wpm-target-status">
                    <p>WPM लक्ष्य:</p>
                    <p class="status-neutral">N/A</p>
                </div>
                <div id="accuracy-target-status">
                    <p>एक्यूरेसी लक्ष्य:</p>
                    <p class="status-neutral">N/A</p>
                </div>
            </div>

            <div class="error-details">
                <h3>त्रुटि विवरण:</h3>
                <p>गलत अक्षर: <span id="err-incorrect-chars">0</span></p>
                <p>छूटे हुए अक्षर: <span id="err-missed-chars">0</span></p>
                <p>अतिरिक्त अक्षर: <span id="err-extra-chars">0</span></p>
                <p>छूटे हुए शब्द: <span id="err-skipped-words">0</span></p>
                <p>अतिरिक्त शब्द: <span id="err-extra-words">0</span></p>
                <p>गलत एंटर: <span id="err-incorrect-enter">0</span></p>
                <p>गलत स्पेस: <span id="err-incorrect-space">0</span></p>
            </div>

            <div class="result-buttons">
                <button id="modal-restart-button">पुनः टेस्ट</button>
                <button id="modal-settings-button" class="secondary">सेटिंग्स बदलें</button>
            </div>
        </div>
    </div>

    <script>
        // --- Global Variables (Declare at the top for scope) ---
        let timerInterval;
        let startTime;
        let timeLeft;
        let defaultTestDuration = 5 * 60; // Default to 5 minutes
        let wordIndex = 0;
        let charIndex = 0;
        let correctChars = 0;
        let totalTypedChars = 0;
        let testWords = [];
        let isTestRunning = false;
        let errors = {
            incorrectChars: 0,
            missedChars: 0,
            extraChars: 0,
            skippedWords: 0,
            extraWords: 0,
            incorrectEnter: 0,
            incorrectSpace: 0
        };
        let userTargetWPM = null;
        let userTargetAccuracy = null;
        let currentStoryType = 'random-words'; // Default story type
        let customStoryText = '';
        let selectedFont = 'Noto Sans Devanagari'; // Default font
        let totalExpectedCharsInTest = 0;
        let highestWPM = 0;
        let highestCPM = 0;
        let highestKDPH = 0;
        let isComposing = false; // Flag for IME composition


        // --- DOM Elements (Get references to all necessary elements once) ---
        // Main UI Elements
        const testArea = document.getElementById('test-area');
        const typingInput = document.getElementById('typing-input');
        const countdownDisplay = document.getElementById('countdown');
        const wpmDisplay = document.getElementById('wpm-display');
        const accuracyDisplay = document.getElementById('accuracy-display');
        const errorsDisplay = document.getElementById('errors-display');
        const cpmDisplay = document.getElementById('cpm-display');
        const kdphDisplay = document.getElementById('kdph-display');
        const restartButton = document.getElementById('restart-button');
        const settingsButton = document.getElementById('settings-button');
        const mainContent = document.querySelector('.main-content'); // Assuming you have a main content div

        // Progress Bars
        const wpmProgressBar = document.getElementById('wpm-progress-bar-fill');
        const accuracyProgressBar = document.getElementById('accuracy-progress-bar-fill');
        const errorsProgressBar = document.getElementById('errors-progress-bar-fill');
        const cpmProgressBar = document.getElementById('cpm-progress-bar-fill');
        const kdphProgressBar = document.getElementById('kdph-progress-bar-fill');
        const timeProgressBar = document.getElementById('time-progress-bar-fill');
        const finalConclusionProgressBarFill = document.getElementById('final-conclusion-progress-bar-fill');


        // Settings Overlay Elements
        const settingsOverlay = document.getElementById('settings-overlay');
        const testDurationSelect = document.getElementById('test-duration');
        const targetWpmInput = document.getElementById('target-wpm');
        const targetAccuracyInput = document.getElementById('target-accuracy');
        const storyTypeSelect = document.getElementById('story-type');
        const customStoryArea = document.getElementById('custom-story-area');
        const customStoryTextarea = document.getElementById('custom-story-textarea');
        const saveSettingsButton = document.getElementById('save-settings-button');
        const skipSettingsButton = document.getElementById('skip-settings-button');
        const fontSelect = document.getElementById('font-select'); // Font selection element
        const krutidevWarning = document.getElementById('krutidev-warning'); // Kruti Dev warning element
        const addStoryLinkButton = document.getElementById('add-story-link-button');


        // Result Modal Elements
        const resultModal = document.getElementById('result-modal');
        const finalWpmDisplay = document.getElementById('final-wpm-display');
        const rawWPMDisplay = document.getElementById('raw-wpm-display'); // <-- यहाँ जोड़ा गया!
        const finalAccuracyDisplay = document.getElementById('final-accuracy-display');
        const finalErrorsDisplay = document.getElementById('final-errors-display');
        const finalCpmDisplay = document.getElementById('final-cpm-display');
        const finalKdphDisplay = document.getElementById('final-kdph-display');

        const errIncorrectChars = document.getElementById('err-incorrect-chars');
        const errMissedChars = document.getElementById('err-missed-chars');
        const errExtraChars = document.getElementById('err-extra-chars');
        const errSkippedWords = document.getElementById('err-skipped-words');
        const errExtraWords = document.getElementById('err-extra-words');
        const errIncorrectEnter = document.getElementById('err-incorrect-enter');
        const errIncorrectSpace = document.getElementById('err-incorrect-space');

        const wpmTargetStatus = document.getElementById('wpm-target-status');
        const accuracyTargetStatus = document.getElementById('accuracy-target-status');

        const modalRestartButton = document.getElementById('modal-restart-button');
        const modalSettingsButton = document.getElementById('modal-settings-button');


        // --- Utility Functions ---

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        function setProgressBar(element, percentage) {
            element.style.width = `${Math.min(100, Math.max(0, percentage))}%`;
        }

        function applyFont(fontName) {
            // Remove all font classes first to ensure only one is applied
            testArea.classList.remove('font-mangal', 'font-krutidev', 'font-hind', 'font-noto');
            typingInput.classList.remove('font-mangal', 'font-krutidev', 'font-hind', 'font-noto');

            switch (fontName) {
                case 'Mangal':
                    testArea.classList.add('font-mangal');
                    typingInput.classList.add('font-mangal');
                    break;
                case 'Kruti Dev 010':
                    testArea.classList.add('font-krutidev');
                    typingInput.classList.add('font-krutidev');
                    krutidevWarning.classList.add('show');
                    break;
                case 'Hind Siliguri':
                    testArea.classList.add('font-hind');
                    typingInput.classList.add('font-hind');
                    break;
                case 'Noto Sans Devanagari':
                default:
                    testArea.classList.add('font-noto');
                    typingInput.classList.add('font-noto');
                    break;
            }
            // Hide Kruti Dev warning if another font is selected
            if (fontName !== 'Kruti Dev 010') {
                krutidevWarning.classList.remove('show');
            }
        }

        // --- Story Fetching (Placeholder, replace with actual API calls if needed) ---

        async function fetchAIGeneratedStory(lengthCategory) {
            // This is a placeholder. In a real application, you'd fetch from an API.
            // For now, it returns fixed Hindi text.
            let stories = {
                'short': [
                    "एक बार की बात है, एक जंगल में एक शेर रहता था। वह बहुत शक्तिशाली था और सभी जानवर उससे डरते थे। एक दिन, शेर को एक छोटा चूहा मिला। शेर ने चूहे को खाने का फैसला किया, लेकिन चूहे ने उससे दया की भीख मांगी। चूहे ने कहा कि वह शेर के काम आ सकता है। शेर को हंसी आई, लेकिन उसने चूहे को जाने दिया।",
                    "सूरज धीरे-धीरे आकाश में उदय हो रहा था, और उसकी सुनहरी किरणें पृथ्वी पर फैल रही थीं। पक्षी चहचहा रहे थे, और हवा में ताज़गी थी। एक किसान अपने खेत की ओर जा रहा था, उसके चेहरे पर शांति और संतुष्टि थी। वह जानता था कि एक नया दिन नई उम्मीदें लेकर आया है।",
                    "बारिश की बूँदें खिड़की से टकरा रही थीं, और अंदर एक आरामदायक गर्माहट थी। एक बच्चा अपनी दादी की गोद में बैठकर कहानी सुन रहा था। कहानी में एक बहादुर राजकुमार और एक जादुई तलवार थी। बच्चे की आँखें चमक रही थीं, क्योंकि वह हर शब्द को जी रहा था।"
                ],
                'medium': [
                    "एक छोटे से गाँव में एक साधु रहता था। वह अपनी बुद्धिमत्ता और दयालुता के लिए जाना जाता था। लोग दूर-दूर से उसकी सलाह लेने आते थे। एक बार, एक धनी व्यापारी उसके पास आया और पूछा, 'जीवन का अर्थ क्या है?' साधु मुस्कुराया और कहा, 'जीवन का अर्थ खोजने में नहीं, बल्कि उसे जीने में है। हर पल को जियो, और तुम्हें अर्थ मिल जाएगा।' व्यापारी ने साधु की बात पर विचार किया और एक नया दृष्टिकोण प्राप्त किया। उसने अपने धन का उपयोग दूसरों की मदद करने के लिए करना शुरू कर दिया, और उसे सच्ची खुशी मिली।",
                    "प्राचीन काल में, एक राजा था जिसने अपने राज्य को बहुत समृद्ध बनाया। उसके पास एक विशाल सेना और अद्भुत खजाने थे। लेकिन राजा हमेशा चिंतित रहता था कि कोई उसके राज्य पर हमला न कर दे। एक दिन, एक बुद्धिमान गुरु उसके महल में आए। राजा ने उनसे पूछा, 'मैं अपने मन की शांति कैसे पा सकता हूँ?' गुरु ने उत्तर दिया, 'सच्ची शांति बाहर नहीं, बल्कि तुम्हारे अंदर है। जब तुम अपनी इच्छाओं और भय को त्याग दोगे, तब तुम्हें शांति मिलेगी।' राजा ने गुरु के शब्दों का पालन किया और अंततः उसे सच्ची शांति और खुशी मिली।"
                ],
                'long': [
                    "हिमालय की ऊँची चोटियों पर, एक छोटा सा मठ था जहाँ एक युवा भिक्षु तपस्या कर रहा था। उसका नाम आनंद था, और वह ज्ञान की खोज में था। कई वर्षों तक उसने ध्यान किया, लेकिन उसे लगा कि कुछ गायब है। एक दिन, एक बूढ़ा यात्री मठ में आया। उसने आनंद को देखा और मुस्कुराया। यात्री ने कहा, 'ज्ञान केवल ग्रंथों में नहीं मिलता, बल्कि जीवन के अनुभवों में भी है। जाओ, दुनिया देखो, लोगों से मिलो, और तुम सच को पाओगे।' आनंद ने यात्री की सलाह मानी और अपनी यात्रा पर निकल पड़ा। उसने कई गाँवों और शहरों का दौरा किया, विभिन्न संस्कृतियों के लोगों से मिला, और जीवन के हर पहलू से सीखा। उसने गरीबी और धन, खुशी और दुख, प्रेम और हानि का अनुभव किया। इन अनुभवों ने उसे सच्ची समझ दी, और उसे एहसास हुआ कि जीवन का सबसे बड़ा ज्ञान स्वयं जीवन में ही निहित है। जब वह मठ लौटा, तो वह एक प्रबुद्ध व्यक्ति बन चुका था, और उसने दूसरों को भी अपने ज्ञान से लाभान्वित किया। उसकी कहानी दूर-दूर तक फैल गई, और लोग उसकी बुद्धिमत्ता और दयालुता के लिए उसे पूजने लगे।",
                    "एक समय की बात है, एक जादुई जंगल था जहाँ पेड़ बात कर सकते थे और जानवर गाना गा सकते थे। जंगल के बीच में एक प्राचीन वृक्ष था, जिसे जीवन का वृक्ष कहा जाता था। इसकी जड़ें पृथ्वी में गहराई तक फैली हुई थीं, और इसकी शाखाएँ आकाश को छूती थीं। एक युवा लड़की, जिसका नाम लीला था, जंगल में रहती थी। वह बहुत साहसी और जिज्ञासु थी। एक दिन, उसे जीवन के वृक्ष के बारे में एक रहस्य पता चला। कहा जाता था कि जो कोई भी उसके फलों को खाएगा, वह अमर हो जाएगा। लीला ने फलों की तलाश करने का फैसला किया, लेकिन जंगल के संरक्षक, एक बूढ़े उल्लू ने उसे चेतावनी दी। उल्लू ने कहा, 'अमरता एक आशीर्वाद नहीं, बल्कि एक अभिशाप हो सकती है। जीवन का चक्र महत्वपूर्ण है।' लीला ने उल्लू की बात नहीं मानी और फलों को खा लिया। शुरुआत में, वह खुशी थी, लेकिन जल्द ही उसे एहसास हुआ कि अमरता का मतलब हमेशा के लिए अकेले रहना है, जबकि उसके प्रियजन बूढ़े होकर मर जाते हैं। उसने अपनी गलती का एहसास किया और उल्लू से मदद मांगी। उल्लू ने उसे एक जादुई मंत्र बताया जिससे वह अपनी अमरता को त्याग सकती थी। लीला ने मंत्र का जाप किया, और उसे फिर से नश्वरता मिल गई। उसने खुशी-खुशी अपने जीवन को जिया, और उसने अमरता के बजाय जीवन की सुंदरता को महत्व दिया।"
                ],
                'random-words': [
                    "भारत विज्ञान अंतरिक्ष यात्रा प्रौद्योगिकी भविष्य विकास शिक्षा ज्ञान कौशल महत्वपूर्ण",
                    "प्रकृति जंगल पहाड़ नदियाँ जीवन पशु पक्षी पर्यावरण संरक्षण जलवायु परिवर्तन",
                    "शहर लोग भीड़ यातायात इमारतें सड़कें आवागमन संस्कृति विविधता शहरीकरण",
                    "किताबें पढ़ना कहानी उपन्यास साहित्य कविता नाटक लेखन मनोरंजन ज्ञान",
                    "स्वास्थ्य भोजन पोषण व्यायाम योग ध्यान शांति मन शरीर आत्मा संतुलन",
                    "दोस्ती प्यार संबंध परिवार समाज सहयोग समर्थन विश्वास एकजुटता समुदाय",
                    "संगीत नृत्य कला चित्रकला मूर्तिकला रचनात्मकता अभिव्यक्ति प्रेरणा सौंदर्य",
                    "अर्थव्यवस्था व्यापार वाणिज्य उद्योग उत्पादन उपभोक्ता बाजार प्रतिस्पर्धा",
                    "राजनीति सरकार कानून न्याय लोकतंत्र चुनाव नागरिक अधिकार कर्तव्य",
                    "धर्म अध्यात्म पूजा प्रार्थना ध्यान मोक्ष शांति आत्मा परमात्मा"
                ]
            };

            if (lengthCategory === 'ai-story') { // Fallback if called directly without a specific length
                lengthCategory = 'medium';
            }

            const categoryStories = stories[lengthCategory] || stories['random-words'];
            const randomIndex = Math.floor(Math.random() * categoryStories.length);
            return categoryStories[randomIndex];
        }


        // --- Test Logic Functions ---

        async function generateAndRenderTestWords() {
            testWords = [];
            testArea.innerHTML = '';
            totalExpectedCharsInTest = 0;

            let textToType = "";

            if (currentStoryType === 'ai-story') {
                let lengthCategory = 'medium';
                const durationMinutes = parseInt(testDurationSelect.value);
                if (durationMinutes <= 2) {
                    lengthCategory = 'short';
                } else if (durationMinutes >= 10) {
                    lengthCategory = 'long';
                }
                textToType = await fetchAIGeneratedStory(lengthCategory);
            } else if (currentStoryType === 'user-custom') {
                textToType = customStoryText.trim();
                if (textToType === "") {
                    alert("कृपया टेक्स्ट एरिया में अपनी कस्टम कहानी पेस्ट करें या कोई अन्य कहानी प्रकार चुनें।");
                    settingsOverlay.classList.add('show');
                    mainContent.classList.add('content-hidden');
                    return false;
                }
            } else {
                textToType = await fetchAIGeneratedStory('random-words');
            }

            const paragraphs = textToType.split(/\r?\n/);

            paragraphs.forEach((paragraphText, paraIdx) => {
                const paragraphDiv = document.createElement('div');
                paragraphDiv.classList.add('paragraph');

                // Split words in a paragraph by one or more spaces
                const wordsWithSpaces = paragraphText.match(/\S+\s*|\s+/g) || [];

                wordsWithSpaces.forEach((item) => {
                    if (item.trim() === '') {
                        // If it's just spaces, treat as part of the word's trailing spaces
                        totalExpectedCharsInTest += item.length;
                    } else {
                        const actualWord = item.trim();
                        testWords.push(actualWord);
                        totalExpectedCharsInTest += actualWord.length;

                        const wordSpan = document.createElement('span');
                        wordSpan.classList.add('word');
                        actualWord.split('').forEach(char => {
                            const charSpan = document.createElement('span');
                            charSpan.textContent = char;
                            charSpan.classList.add('untyped');
                            wordSpan.appendChild(charSpan);
                        });

                        const trailingSpaces = item.substring(actualWord.length);
                        for (let i = 0; i < trailingSpaces.length; i++) {
                            const charSpan = document.createElement('span');
                            charSpan.textContent = trailingSpaces[i];
                            charSpan.classList.add('untyped');
                            wordSpan.appendChild(charSpan);
                        }
                        totalExpectedCharsInTest += trailingSpaces.length;

                        paragraphDiv.appendChild(wordSpan);
                    }
                });

                if (paraIdx < paragraphs.length - 1) {
                    const newlineMarker = document.createElement('span');
                    newlineMarker.classList.add('newline-marker');
                    paragraphDiv.appendChild(newlineMarker);

                    testWords.push('\n'); // Add newline as a distinct item for logic
                    totalExpectedCharsInTest++; // Count newline marker as a character
                }

                testArea.appendChild(paragraphDiv);
            });

            highlightCurrentWord();
            adjustTestAreaScroll();
            updateAllProgressBars(); // Initialize all progress bars
            return true;
        }

        function getDomElementForTestItem(targetIndex) {
            let currentTraversalIndex = 0;
            const paragraphs = testArea.querySelectorAll('.paragraph');

            for (let i = 0; i < paragraphs.length; i++) {
                const paragraphDiv = paragraphs[i];
                const children = Array.from(paragraphDiv.children);

                for (let j = 0; j < children.length; j++) {
                    const child = children[j];
                    if (currentTraversalIndex === targetIndex) {
                        return child;
                    }
                    currentTraversalIndex++;
                }
            }
            return null;
        }

        function highlightCurrentWord() {
            testArea.querySelectorAll('.word').forEach(span => {
                span.classList.remove('current-word');
            });
            testArea.querySelectorAll('.newline-marker').forEach(marker => {
                marker.classList.remove('current-newline-marker');
            });

            if (wordIndex >= testWords.length) {
                adjustTestAreaScroll();
                return;
            }

            const currentItem = testWords[wordIndex];
            const currentDomElement = getDomElementForTestItem(wordIndex);

            if (currentItem === '\n') {
                if (currentDomElement && currentDomElement.classList.contains('newline-marker')) {
                    currentDomElement.classList.add('current-newline-marker');
                    adjustTestAreaScroll();
                }
            } else if (currentDomElement && currentDomElement.classList.contains('word')) {
                currentDomElement.classList.add('current-word');
                adjustTestAreaScroll();
            }
        }

        function adjustTestAreaScroll() {
            const currentDomElement = getDomElementForTestItem(wordIndex);
            if (!currentDomElement) return;

            const testAreaRect = testArea.getBoundingClientRect();
            const targetRect = currentDomElement.getBoundingClientRect();

            // Scroll down if current word is below the visible area
            if (targetRect.bottom > testAreaRect.bottom) {
                testArea.scrollTop += (targetRect.bottom - testAreaRect.bottom) + 10;
            }
            // Scroll up if current word is above the visible area
            else if (targetRect.top < testAreaRect.top) {
                testArea.scrollTop -= (testAreaRect.top - targetRect.top) + 10;
            }
        }

        function updateAllProgressBars() {
            const timeElapsed = (defaultTestDuration - timeLeft);
            const minutesElapsed = timeElapsed / 60;
            const hoursElapsed = timeElapsed / 3600;

            const currentWPM = Math.max(0, ((correctChars - (errors.incorrectChars + errors.missedChars + errors.extraChars + (errors.skippedWords * 5) + (errors.extraWords * 5) + errors.incorrectEnter + errors.incorrectSpace)) / 5) / (minutesElapsed || 1));
            const currentAccuracy = totalTypedChars === 0 ? 0 : Math.round((correctChars / totalTypedChars) * 100);
            const totalErrors = errors.incorrectChars + errors.missedChars + errors.extraChars + errors.skippedWords + errors.extraWords + errors.incorrectEnter + errors.incorrectSpace;
            const currentCPM = correctChars / (minutesElapsed || 1);
            const currentKDPH = correctChars / (hoursElapsed || 1);


            // Update highest WPM, CPM, KDPH for better scaling if current value exceeds previous highest
            if (currentWPM > highestWPM) highestWPM = currentWPM;
            if (currentCPM > highestCPM) highestCPM = currentCPM;
            if (currentKDPH > highestKDPH) highestKDPH = currentKDPH;

            // WPM Progress Bar
            const maxWPMForScale = Math.max(100, highestWPM + 20); // Add a buffer for better visual range
            let wpmProgress = (currentWPM / maxWPMForScale) * 100;
            setProgressBar(wpmProgressBar, wpmProgress);

            // Accuracy Progress Bar (0-100%)
            setProgressBar(accuracyProgressBar, currentAccuracy);

            // Errors Progress Bar (More errors = wider bar)
            const maxErrorsForScale = Math.max(50, totalExpectedCharsInTest * 0.15); // e.g., 15% of expected chars
            const errorProgress = (totalErrors / maxErrorsForScale) * 100;
            setProgressBar(errorsProgressBar, errorProgress);

            // CPM Progress Bar
            const maxCPMForScale = Math.max(500, highestCPM + 100);
            let cpmProgress = (currentCPM / maxCPMForScale) * 100;
            setProgressBar(cpmProgressBar, cpmProgress);

            // KDPH Progress Bar
            const maxKDPHForScale = Math.max(5000, highestKDPH + 500);
            let kdphProgress = (currentKDPH / maxKDPHForScale) * 100;
            setProgressBar(kdphProgressBar, kdphProgress);

            // Time Left Progress Bar (100%-0%)
            const timeLeftPercentage = (timeLeft / defaultTestDuration) * 100;
            setProgressBar(timeProgressBar, timeLeftPercentage);
        }


        function updateStats() {
            const timeElapsed = (defaultTestDuration - timeLeft);
            if (!isTestRunning || timeElapsed === 0) {
                wpmDisplay.textContent = 0;
                accuracyDisplay.textContent = 0;
                errorsDisplay.textContent = errors.incorrectChars + errors.missedChars + errors.extraChars + errors.skippedWords + errors.extraWords + errors.incorrectEnter + errors.incorrectSpace;
                cpmDisplay.textContent = 0;
                kdphDisplay.textContent = 0;
                updateAllProgressBars();
                return;
            }

            const minutesElapsed = timeElapsed / 60;
            const hoursElapsed = timeElapsed / 3600;

            const totalCalculatedErrors = errors.incorrectChars + errors.missedChars + errors.extraChars +
                                        (errors.skippedWords * 5) + (errors.extraWords * 5) + errors.incorrectEnter + errors.incorrectSpace;


            const netWPM = ((correctChars - totalCalculatedErrors) / 5) / minutesElapsed;
            wpmDisplay.textContent = Math.max(0, Math.round(netWPM));

            const currentCPM = correctChars / minutesElapsed;
            cpmDisplay.textContent = isNaN(currentCPM) ? 0 : Math.round(currentCPM);

            const currentKDPH = (correctChars / hoursElapsed);
            kdphDisplay.textContent = isNaN(currentKDPH) ? 0 : Math.round(currentKDPH);


            const currentAccuracy = totalTypedChars === 0 ? 0 : Math.round((correctChars / totalTypedChars) * 100);
            accuracyDisplay.textContent = isNaN(currentAccuracy) ? 0 : currentAccuracy;

            errorsDisplay.textContent = totalCalculatedErrors;

            updateAllProgressBars();
        }

        function startTimer() {
            startTime = Date.now();
            isTestRunning = true;
            timerInterval = setInterval(() => {
                timeLeft--;
                countdownDisplay.textContent = formatTime(timeLeft);
                updateStats();

                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    endTest();
                }
            }, 1000);
        }

        function endTest() {
            isTestRunning = false;
            typingInput.disabled = true;
            typingInput.value = '';
            clearInterval(timerInterval);

            // Calculate remaining skipped words/newlines for the final stats
            for (let i = wordIndex; i < testWords.length; i++) {
                if (testWords[i] !== '\n') {
                    errors.skippedWords++;
                } else {
                    errors.missedChars++; // Count newline marker as a missed character if not typed
                }
            }


            updateStats(); // Final update to live stats before modal shows

            const timeElapsed = (defaultTestDuration - timeLeft);
            const finalMinutesElapsed = timeElapsed / 60;
            const finalHoursElapsed = timeElapsed / 3600;

            if (finalMinutesElapsed === 0) {
                 finalWpmDisplay.textContent = 0;
                 finalAccuracyDisplay.textContent = 0;
                 finalErrorsDisplay.textContent = 0;
                 rawWPMDisplay.textContent = 0;
                 finalCpmDisplay.textContent = 0;
                 finalKdphDisplay.textContent = 0;
            } else {
                const totalCalculatedErrors = errors.incorrectChars + errors.missedChars + errors.extraChars +
                                            (errors.skippedWords * 5) + (errors.extraWords * 5) + errors.incorrectEnter + errors.incorrectSpace;

                const finalNetWPM = Math.max(0, ((correctChars - totalCalculatedErrors) / 5) / finalMinutesElapsed);
                finalWpmDisplay.textContent = Math.round(finalNetWPM);

                const finalRawWPM = (totalTypedChars / 5) / finalMinutesElapsed;
                rawWPMDisplay.textContent = Math.round(finalRawWPM);

                const finalAccuracy = totalTypedChars === 0 ? 0 : Math.round((correctChars / totalTypedChars) * 100);
                finalAccuracyDisplay.textContent = finalAccuracy;

                const finalCPM = correctChars / finalMinutesElapsed;
                finalCpmDisplay.textContent = Math.round(finalCPM);

                const finalKDPH = correctChars / finalHoursElapsed;
                finalKdphDisplay.textContent = Math.round(finalKDPH);

                finalErrorsDisplay.textContent = totalCalculatedErrors;
            }

            errIncorrectChars.textContent = errors.incorrectChars;
            errMissedChars.textContent = errors.missedChars;
            errExtraChars.textContent = errors.extraChars;
            errSkippedWords.textContent = errors.skippedWords;
            errExtraWords.textContent = errors.extraWords;
            errIncorrectEnter.textContent = errors.incorrectEnter;
            errIncorrectSpace.textContent = errors.incorrectSpace;


            finalWpmDisplay.className = 'result-value-green';
            finalAccuracyDisplay.className = 'result-value-green';
            finalErrorsDisplay.className = 'result-value-red';
            rawWPMDisplay.className = 'result-value-purple';
            finalCpmDisplay.className = 'result-value-orange';
            finalKdphDisplay.className = 'result-value-kdph';

            // Final Conclusion Progress Bar (a weighted average of WPM and Accuracy, penalizing errors)
            let wpmScore = parseFloat(finalWpmDisplay.textContent);
            let accuracyScore = parseFloat(finalAccuracyDisplay.textContent);
            let totalErrors = parseFloat(finalErrorsDisplay.textContent);

            // Normalize scores to a 0-100 range for the final bar
            // Assuming a good WPM is 40-60, excellent is 80+, so scale WPM towards 100
            let normalizedWPM = (wpmScore / 60) * 100; // Aiming for 60 WPM as a benchmark for 100% WPM score
            normalizedWPM = Math.min(100, Math.max(0, normalizedWPM)); // Clamp between 0 and 100

            let normalizedAccuracy = accuracyScore;

            // Penalty for errors: e.g., 1 point deduction for every 5 errors (adjustable)
            let errorPenalty = (totalErrors / 5) * 1;
            errorPenalty = Math.min(50, errorPenalty); // Cap penalty to prevent negative scores

            let finalConclusionProgress = (normalizedWPM * 0.6) + (normalizedAccuracy * 0.4) - errorPenalty; // Weighted average
            finalConclusionProgress = Math.max(0, Math.min(100, finalConclusionProgress)); // Cap between 0 and 100

            // Apply the single color for the final bar
            setProgressBar(finalConclusionProgressBarFill, finalConclusionProgress);


            // Check and update target status
            if (userTargetWPM !== null && !isNaN(userTargetWPM)) {
                if (parseFloat(finalWpmDisplay.textContent) >= userTargetWPM) {
                    wpmTargetStatus.querySelector('p').textContent = `Achieved (${userTargetWPM} WPM)`;
                    wpmTargetStatus.querySelector('p').className = 'status-met';
                } else {
                    wpmTargetStatus.querySelector('p').textContent = `Not Achieved (${userTargetWPM} WPM)`;
                    wpmTargetStatus.querySelector('p').className = 'status-not-met';
                }
            } else {
                wpmTargetStatus.querySelector('p').textContent = 'N/A';
                wpmTargetStatus.querySelector('p').className = 'status-neutral';
            }

            if (userTargetAccuracy !== null && !isNaN(userTargetAccuracy)) {
                if (parseFloat(finalAccuracyDisplay.textContent) >= userTargetAccuracy) {
                    accuracyTargetStatus.querySelector('p').textContent = `Achieved (${userTargetAccuracy}%)`;
                    accuracyTargetStatus.querySelector('p').className = 'status-met';
                } else {
                    accuracyTargetStatus.querySelector('p').textContent = `Not Achieved (${userTargetAccuracy}%)`;
                    accuracyTargetStatus.querySelector('p').className = 'status-not-met';
                }
            } else {
                accuracyTargetStatus.querySelector('p').textContent = 'N/A';
                accuracyTargetStatus.querySelector('p').className = 'status-neutral';
            }

            // Ensure the result modal is shown.
            console.log("Attempting to show result modal."); // Debugging log
            console.log("Result Modal Element:", resultModal); // Log the element itself
            console.log("Result Modal's current classes before 'add':", resultModal.classList); // Check classes before adding 'show'
            resultModal.classList.add('show');
            // Add a small delay to ensure CSS transition has time to process (though 'visibility 0s' should make it instant)
            setTimeout(() => {
                console.log("Result Modal's current classes AFTER 'add' and slight delay:", resultModal.classList);
                if (resultModal.style.visibility === 'hidden' || resultModal.style.opacity === '0') {
                    console.error("Result modal is still hidden or transparent despite 'show' class.");
                }
            }, 50); // A small delay to see if something immediately overrides


            // Make sure the main content is hidden when modal shows to avoid overlapping
            mainContent.classList.add('content-hidden');


            restartButton.disabled = false;
            settingsButton.disabled = false;
        }

        async function initializeTest(duration, targetWPM, targetAccuracy, storyType, customText = '', font = 'Noto Sans Devanagari') {
            clearInterval(timerInterval);
            defaultTestDuration = duration * 60;
            timeLeft = defaultTestDuration;
            countdownDisplay.textContent = formatTime(timeLeft);
            wordIndex = 0;
            charIndex = 0;
            correctChars = 0;
            totalTypedChars = 0;
            totalExpectedCharsInTest = 0;
            errors = {
                incorrectChars: 0,
                missedChars: 0,
                extraChars: 0,
                skippedWords: 0,
                extraWords: 0,
                incorrectEnter: 0,
                incorrectSpace: 0
            };
            highestWPM = 0; // Reset highest values
            highestCPM = 0;
            highestKDPH = 0;
            isComposing = false; // Reset composition flag


            typingInput.value = '';
            typingInput.disabled = false;
            startTime = null;
            isTestRunning = false;

            userTargetWPM = targetWPM ? parseInt(targetWPM) : null;
            userTargetAccuracy = targetAccuracy ? parseInt(targetAccuracy) : null;
            currentStoryType = storyType;
            customStoryText = customText;
            selectedFont = font; // Set the selected font

            wpmDisplay.textContent = '0';
            accuracyDisplay.textContent = '0';
            errorsDisplay.textContent = '0';
            cpmDisplay.textContent = '0';
            kdphDisplay.textContent = '0';

            // Reset all progress bars visually to 0% and their initial (or appropriate) fill
            setProgressBar(wpmProgressBar, 0);
            setProgressBar(accuracyProgressBar, 0);
            setProgressBar(errorsProgressBar, 0);
            setProgressBar(cpmProgressBar, 0);
            setProgressBar(kdphProgressBar, 0);
            setProgressBar(timeProgressBar, 100); // Time starts full

            restartButton.disabled = false;
            settingsButton.disabled = false;

            applyFont(selectedFont); // Apply the selected font

            const generationSuccess = await generateAndRenderTestWords();
            if (!generationSuccess) {
                return;
            }

            typingInput.focus();
            resultModal.classList.remove('show'); // Ensure it's hidden before starting new test
            settingsOverlay.classList.remove('show');
            mainContent.classList.remove('content-hidden');
        }


        // Event Listeners

        typingInput.addEventListener('compositionstart', () => {
            isComposing = true;
        });

        typingInput.addEventListener('compositionend', () => {
            isComposing = false;
            // Trigger input processing if composition has ended and there's text
            if (typingInput.value.length > 0) {
                processInput();
            }
        });

        typingInput.addEventListener('input', (e) => {
            if (!isTestRunning && startTime === null) {
                startTimer();
            }
            // Only process input directly if not composing
            if (!isComposing) {
                processInput();
            }
        });

        function processInput() {
            const currentExpectedItem = testWords[wordIndex];
            const typedText = typingInput.value;

            if (!currentExpectedItem) return; // Test might have ended

            if (currentExpectedItem === '\n') {
                // If expecting a newline, and user types something, clear input
                // This prevents typing into the story text if the system doesn't auto-handle enter
                if (typedText.length > 0) {
                    typingInput.value = ''; // Clear input if user types instead of pressing Enter for newline
                }
                return;
            }

            const currentWordSpan = getDomElementForTestItem(wordIndex);

            if (!currentWordSpan || !currentWordSpan.classList.contains('word')) {
                return;
            }
            const currentWordExpected = currentExpectedItem; // Define here for clarity

            const charSpans = Array.from(currentWordSpan.querySelectorAll('span'));

            // Reset classes for current word's characters
            charSpans.forEach(span => {
                span.classList.remove('correct', 'incorrect', 'extra');
                span.classList.add('untyped');
                span.style.display = 'inline';
            });

            // Remove previous extra characters
            currentWordSpan.querySelectorAll('.extra').forEach(el => el.remove());

            // Add new extra characters
            if (typedText.length > currentWordExpected.length) {
                for (let i = currentWordExpected.length; i < typedText.length; i++) {
                    const extraSpan = document.createElement('span');
                    extraSpan.textContent = typedText[i];
                    extraSpan.classList.add('extra');
                    currentWordSpan.appendChild(extraSpan);
                }
            }


            // Mark characters as correct/incorrect
            // This loop should run after adding extra spans, to ensure it doesn't affect existing chars
            let newCorrectCharsCount = 0; // Track correct chars for current typed segment only
            for (let i = 0; i < currentWordExpected.length; i++) {
                const charExpected = currentWordExpected[i];
                const typedChar = typedText[i];
                const charSpan = charSpans[i];

                if (charSpan) {
                    if (typedChar === undefined) {
                        charSpan.classList.add('untyped');
                    } else if (typedChar === charExpected) {
                        charSpan.classList.add('correct');
                        newCorrectCharsCount++;
                    } else {
                        charSpan.classList.add('incorrect');
                    }
                }
            }

            // Update charIndex based on current input length
            charIndex = typedText.length;

            updateStats();
        }


        typingInput.addEventListener('keydown', (e) => {
            if (!isTestRunning && startTime === null) {
                startTimer();
            }

            // If a composition is in progress (e.g., swiping on mobile), don't process keydown events directly
            // Wait for 'compositionend' to finalize the input.
            if (isComposing) {
                return;
            }

            const currentExpectedItem = testWords[wordIndex];
            const typedText = typingInput.value;

            // Handle Spacebar
            if (e.key === ' ' || e.keyCode === 32 || e.which === 32) {
                e.preventDefault(); // Prevent default space behavior

                // If expecting a newline, and user presses space, it's an incorrect space
                if (currentExpectedItem === '\n') {
                    errors.incorrectSpace++;
                    totalTypedChars++; // Count the space as a typed character
                    typingInput.value = ''; // Clear input for next word
                    updateStats();
                    return; // Do not advance wordIndex here
                }

                // Process the word typed before the space
                const currentWordExpected = currentExpectedItem;
                let wordTyped = typedText;

                let wordCorrectCharsCount = 0;

                for (let i = 0; i < Math.max(currentWordExpected.length, wordTyped.length); i++) {
                    const expectedChar = currentWordExpected[i];
                    const typedChar = wordTyped[i];

                    if (typedChar === undefined) { // Missed character in expected word
                        errors.missedChars++;
                    } else if (expectedChar === undefined) { // Extra character typed by user
                        errors.extraChars++;
                    } else if (typedChar !== expectedChar) { // Incorrect character typed
                        errors.incorrectChars++;
                    } else { // Correct character
                        wordCorrectCharsCount++;
                    }
                }

                correctChars += wordCorrectCharsCount;
                totalTypedChars += wordTyped.length;
                totalTypedChars++; // Count the space itself as a typed character

                wordIndex++; // Move to the next word/item
                typingInput.value = ''; // Clear input for next word
                charIndex = 0;
                highlightCurrentWord();

                if (wordIndex >= testWords.length) {
                    endTest();
                }
                updateStats();

            // Handle Enter Key
            } else if (e.key === 'Enter' || e.keyCode === 13 || e.which === 13) {
                e.preventDefault(); // Prevent default Enter behavior (e.g., new line in input)

                if (currentExpectedItem === '\n') {
                    // If user typed anything before pressing enter for a newline, count as incorrect chars
                    if (typedText.length > 0) {
                        errors.incorrectChars += typedText.length;
                        totalTypedChars += typedText.length;
                    }

                    correctChars++; // Count the correct 'Enter' as a correct character
                    totalTypedChars++; // Count the 'Enter' as a typed character

                    wordIndex++; // Move to the next word/item
                    typingInput.value = ''; // Clear input
                    charIndex = 0;
                    highlightCurrentWord();

                    if (wordIndex >= testWords.length) {
                        endTest();
                    }
                } else {
                    // If not expecting a newline but user presses Enter, it's an incorrect enter
                    errors.incorrectEnter++;
                    totalTypedChars++; // Count the 'Enter' as a typed character
                }
                updateStats();
            } else if (e.key === 'Backspace') {
                // Allow backspace to modify the typed text
                if (charIndex > 0) {
                    charIndex--;
                }
                // The 'input' event listener will handle the visual update after backspace
            }
        });

        // Add an event listener for when the input field loses focus
        typingInput.addEventListener('blur', () => {
            if (isTestRunning && typingInput.value.length > 0) {
                // If there's text in the input field and the test is running,
                // simulate a spacebar press to process the current word.
                // This is a fallback for mobile keyboards that might not trigger 'keydown' for space.
                const currentExpectedItem = testWords[wordIndex];
                if (currentExpectedItem && currentExpectedItem !== '\n') { // Only process if it's a word
                    // Simulate processing of the current word
                    let wordTyped = typingInput.value;
                    let currentWordExpected = currentExpectedItem;

                    let wordCorrectCharsCount = 0;
                    for (let i = 0; i < Math.max(currentWordExpected.length, wordTyped.length); i++) {
                        const expectedChar = currentWordExpected[i];
                        const typedChar = wordTyped[i];

                        if (typedChar === undefined) {
                            errors.missedChars++;
                        } else if (expectedChar === undefined) {
                            errors.extraChars++;
                        } else if (typedChar !== expectedChar) {
                            errors.incorrectChars++;
                        } else {
                            wordCorrectCharsCount++;
                        }
                    }

                    correctChars += wordCorrectCharsCount;
                    totalTypedChars += wordTyped.length;
                    totalTypedChars++; // Count the implied space/end-of-word

                    wordIndex++;
                    typingInput.value = '';
                    charIndex = 0;
                    highlightCurrentWord();

                    if (wordIndex >= testWords.length) {
                        endTest();
                    }
                    updateStats();
                }
            }
        });


        restartButton.addEventListener('click', () => {
            settingsOverlay.classList.add('show');
            resultModal.classList.remove('show');
            mainContent.classList.add('content-hidden');
            testDurationSelect.value = defaultTestDuration / 60;
            targetWpmInput.value = userTargetWPM || '';
            targetAccuracyInput.value = userTargetAccuracy || '';
            storyTypeSelect.value = currentStoryType;
            fontSelect.value = selectedFont; // Set current font in settings
            if (currentStoryType === 'user-custom') {
                customStoryArea.style.display = 'block';
                customStoryTextarea.value = customStoryText;
            } else {
                customStoryArea.style.display = 'none';
            }
            if (selectedFont === 'Kruti Dev 010') {
                krutidevWarning.classList.add('show');
            } else {
                krutidevWarning.classList.remove('show');
            }
        });

        settingsButton.addEventListener('click', () => {
            settingsOverlay.classList.add('show');
            mainContent.classList.add('content-hidden');
            testDurationSelect.value = defaultTestDuration / 60;
            targetWpmInput.value = userTargetWPM || '';
            targetAccuracyInput.value = userTargetAccuracy || '';
            storyTypeSelect.value = currentStoryType;
            fontSelect.value = selectedFont; // Set current font in settings
            if (currentStoryType === 'user-custom') {
                customStoryArea.style.display = 'block';
                customStoryTextarea.value = customStoryText;
            } else {
                customStoryArea.style.display = 'none';
            }
            if (selectedFont === 'Kruti Dev 010') {
                krutidevWarning.classList.add('show');
            } else {
                krutidevWarning.classList.remove('show');
            }
        });

        saveSettingsButton.addEventListener('click', async () => {
            const duration = parseInt(testDurationSelect.value);
            const targetWPM = targetWpmInput.value;
            const targetAccuracy = targetAccuracyInput.value;
            const storyType = storyTypeSelect.value;
            const font = fontSelect.value; // Get selected font
            let storyContent = '';

            if (storyType === 'user-custom') {
                storyContent = customStoryTextarea.value.trim();
            }
            await initializeTest(duration, targetWPM, targetAccuracy, storyType, storyContent, font);
        });

        skipSettingsButton.addEventListener('click', async () => {
            // Default to Noto Sans Devanagari if skipping settings
            await initializeTest(5, null, null, 'random-words', '', 'Noto Sans Devanagari');
        });

        modalRestartButton.addEventListener('click', async () => {
            // Restart with previous settings including font
            await initializeTest(defaultTestDuration / 60, userTargetWPM, userTargetAccuracy, currentStoryType, customStoryText, selectedFont);
        });

        modalSettingsButton.addEventListener('click', () => {
            resultModal.classList.remove('show');
            settingsOverlay.classList.add('show');
            mainContent.classList.add('content-hidden');
            testDurationSelect.value = defaultTestDuration / 60;
            targetWpmInput.value = userTargetWPM || '';
            targetAccuracyInput.value = userTargetAccuracy || '';
            storyTypeSelect.value = currentStoryType;
            fontSelect.value = selectedFont; // Set current font in settings
            if (currentStoryType === 'user-custom') {
                customStoryArea.style.display = 'block';
                customStoryTextarea.value = customStoryText;
            } else {
                customStoryArea.style.display = 'none';
            }
            if (selectedFont === 'Kruti Dev 010') {
                krutidevWarning.classList.add('show');
            } else {
                krutidevWarning.classList.remove('show');
            }
        });

        storyTypeSelect.addEventListener('change', () => {
            if (storyTypeSelect.value === 'user-custom') {
                customStoryArea.style.display = 'block';
            } else {
                customStoryArea.style.display = 'none';
            }
        });

        // New event listener for font selection
        fontSelect.addEventListener('change', () => {
            selectedFont = fontSelect.value;
            if (selectedFont === 'Kruti Dev 010') {
                krutidevWarning.classList.add('show');
            } else {
                krutidevWarning.classList.remove('show');
            }
        });

        addStoryLinkButton.addEventListener('click', () => {
            // Placeholder for a Hindi story source if found
            alert("कृपया हिंदी कहानियों के लिए एक उपयुक्त स्रोत खोजें। Reedsy मुख्य रूप से अंग्रेजी कहानियों के लिए है।"); // Changed to Hindi
            // window.open('https://example.com/hindi-stories', '_blank'); // Replace with actual Hindi source
        });

        // --- Initial Setup on DOM Load ---
        document.addEventListener('DOMContentLoaded', () => {
            settingsOverlay.classList.add('show');
            mainContent.classList.add('content-hidden');
            countdownDisplay.textContent = formatTime(defaultTestDuration);
            customStoryArea.style.display = 'none';
            krutidevWarning.classList.remove('show'); // Hide warning initially
            // Initialize all progress bars to their starting state
            updateAllProgressBars();
            applyFont(selectedFont); // Apply default font on load
        });
    </script>
</body>
</html>
